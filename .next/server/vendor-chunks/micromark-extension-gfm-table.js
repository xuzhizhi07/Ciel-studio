"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-extension-gfm-table";
exports.ids = ["vendor-chunks/micromark-extension-gfm-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js":
/*!************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditMap: () => (/* binding */ EditMap)\n/* harmony export */ });\n/**\n * @import {Event} from 'micromark-util-types'\n */ // Port of `edit_map.rs` from `markdown-rs`.\n// This should move to `markdown-js` later.\n// Deal with several changes in events, batching them together.\n//\n// Preferably, changes should be kept to a minimum.\n// Sometimes, it’s needed to change the list of events, because parsing can be\n// messy, and it helps to expose a cleaner interface of events to the compiler\n// and other users.\n// It can also help to merge many adjacent similar events.\n// And, in other cases, it’s needed to parse subcontent: pass some events\n// through another tokenizer and inject the result.\n/**\n * @typedef {[number, number, Array<Event>]} Change\n * @typedef {[number, number, number]} Jump\n */ /**\n * Tracks a bunch of edits.\n */ class EditMap {\n    /**\n   * Create a new edit map.\n   */ constructor(){\n        /**\n     * Record of changes.\n     *\n     * @type {Array<Change>}\n     */ this.map = [];\n    }\n    /**\n   * Create an edit: a remove and/or add at a certain place.\n   *\n   * @param {number} index\n   * @param {number} remove\n   * @param {Array<Event>} add\n   * @returns {undefined}\n   */ add(index, remove, add) {\n        addImplementation(this, index, remove, add);\n    }\n    // To do: add this when moving to `micromark`.\n    // /**\n    //  * Create an edit: but insert `add` before existing additions.\n    //  *\n    //  * @param {number} index\n    //  * @param {number} remove\n    //  * @param {Array<Event>} add\n    //  * @returns {undefined}\n    //  */\n    // addBefore(index, remove, add) {\n    //   addImplementation(this, index, remove, add, true)\n    // }\n    /**\n   * Done, change the events.\n   *\n   * @param {Array<Event>} events\n   * @returns {undefined}\n   */ consume(events) {\n        this.map.sort(function(a, b) {\n            return a[0] - b[0];\n        });\n        /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */ if (this.map.length === 0) {\n            return;\n        }\n        // To do: if links are added in events, like they are in `markdown-rs`,\n        // this is needed.\n        // // Calculate jumps: where items in the current list move to.\n        // /** @type {Array<Jump>} */\n        // const jumps = []\n        // let index = 0\n        // let addAcc = 0\n        // let removeAcc = 0\n        // while (index < this.map.length) {\n        //   const [at, remove, add] = this.map[index]\n        //   removeAcc += remove\n        //   addAcc += add.length\n        //   jumps.push([at, removeAcc, addAcc])\n        //   index += 1\n        // }\n        //\n        // . shiftLinks(events, jumps)\n        let index = this.map.length;\n        /** @type {Array<Array<Event>>} */ const vecs = [];\n        while(index > 0){\n            index -= 1;\n            vecs.push(events.slice(this.map[index][0] + this.map[index][1]), this.map[index][2]);\n            // Truncate rest.\n            events.length = this.map[index][0];\n        }\n        vecs.push(events.slice());\n        events.length = 0;\n        let slice = vecs.pop();\n        while(slice){\n            for (const element of slice){\n                events.push(element);\n            }\n            slice = vecs.pop();\n        }\n        // Truncate everything.\n        this.map.length = 0;\n    }\n}\n/**\n * Create an edit.\n *\n * @param {EditMap} editMap\n * @param {number} at\n * @param {number} remove\n * @param {Array<Event>} add\n * @returns {undefined}\n */ function addImplementation(editMap, at, remove, add) {\n    let index = 0;\n    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */ if (remove === 0 && add.length === 0) {\n        return;\n    }\n    while(index < editMap.map.length){\n        if (editMap.map[index][0] === at) {\n            editMap.map[index][1] += remove;\n            // To do: before not used by tables, use when moving to micromark.\n            // if (before) {\n            //   add.push(...editMap.map[index][2])\n            //   editMap.map[index][2] = add\n            // } else {\n            editMap.map[index][2].push(...add);\n            // }\n            return;\n        }\n        index += 1;\n    }\n    editMap.map.push([\n        at,\n        remove,\n        add\n    ]);\n} // /**\n //  * Shift `previous` and `next` links according to `jumps`.\n //  *\n //  * This fixes links in case there are events removed or added between them.\n //  *\n //  * @param {Array<Event>} events\n //  * @param {Array<Jump>} jumps\n //  */\n // function shiftLinks(events, jumps) {\n //   let jumpIndex = 0\n //   let index = 0\n //   let add = 0\n //   let rm = 0\n //   while (index < events.length) {\n //     const rmCurr = rm\n //     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\n //       add = jumps[jumpIndex][2]\n //       rm = jumps[jumpIndex][1]\n //       jumpIndex += 1\n //     }\n //     // Ignore items that will be removed.\n //     if (rm > rmCurr) {\n //       index += rm - rmCurr\n //     } else {\n //       // ?\n //       // if let Some(link) = &events[index].link {\n //       //     if let Some(next) = link.next {\n //       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\n //       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\n //       //             add = jumps[jumpIndex].2;\n //       //             rm = jumps[jumpIndex].1;\n //       //             jumpIndex += 1;\n //       //         }\n //       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\n //       //         index = next;\n //       //         continue;\n //       //     }\n //       // }\n //       index += 1\n //     }\n //   }\n // }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9lZGl0LW1hcC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FFRCw0Q0FBNEM7QUFDNUMsMkNBQTJDO0FBRTNDLCtEQUErRDtBQUMvRCxFQUFFO0FBQ0YsbURBQW1EO0FBQ25ELDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsbUJBQW1CO0FBQ25CLDBEQUEwRDtBQUMxRCx5RUFBeUU7QUFDekUsbURBQW1EO0FBRW5EOzs7Q0FHQyxHQUVEOztDQUVDLEdBQ00sTUFBTUE7SUFDWDs7R0FFQyxHQUNEQyxhQUFjO1FBQ1o7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHLEVBQUU7SUFDZjtJQUVBOzs7Ozs7O0dBT0MsR0FDREMsSUFBSUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVGLEdBQUcsRUFBRTtRQUN0Qkcsa0JBQWtCLElBQUksRUFBRUYsT0FBT0MsUUFBUUY7SUFDekM7SUFFQSw4Q0FBOEM7SUFDOUMsTUFBTTtJQUNOLGlFQUFpRTtJQUNqRSxLQUFLO0lBQ0wsMkJBQTJCO0lBQzNCLDRCQUE0QjtJQUM1QiwrQkFBK0I7SUFDL0IsMEJBQTBCO0lBQzFCLE1BQU07SUFDTixrQ0FBa0M7SUFDbEMsc0RBQXNEO0lBQ3RELElBQUk7SUFFSjs7Ozs7R0FLQyxHQUNESSxRQUFRQyxNQUFNLEVBQUU7UUFDZCxJQUFJLENBQUNOLEdBQUcsQ0FBQ08sSUFBSSxDQUFDLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztZQUMxQixPQUFPRCxDQUFDLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRTtRQUNwQjtRQUVBLG1GQUFtRixHQUNuRixJQUFJLElBQUksQ0FBQ1QsR0FBRyxDQUFDVSxNQUFNLEtBQUssR0FBRztZQUN6QjtRQUNGO1FBRUEsdUVBQXVFO1FBQ3ZFLGtCQUFrQjtRQUNsQiwrREFBK0Q7UUFDL0QsNkJBQTZCO1FBQzdCLG1CQUFtQjtRQUNu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Ly9jaWVsLXN0dWRpby8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL2VkaXQtbWFwLmpzPzA0ZTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtFdmVudH0gZnJvbSAnbWljcm9tYXJrLXV0aWwtdHlwZXMnXG4gKi9cblxuLy8gUG9ydCBvZiBgZWRpdF9tYXAucnNgIGZyb20gYG1hcmtkb3duLXJzYC5cbi8vIFRoaXMgc2hvdWxkIG1vdmUgdG8gYG1hcmtkb3duLWpzYCBsYXRlci5cblxuLy8gRGVhbCB3aXRoIHNldmVyYWwgY2hhbmdlcyBpbiBldmVudHMsIGJhdGNoaW5nIHRoZW0gdG9nZXRoZXIuXG4vL1xuLy8gUHJlZmVyYWJseSwgY2hhbmdlcyBzaG91bGQgYmUga2VwdCB0byBhIG1pbmltdW0uXG4vLyBTb21ldGltZXMsIGl04oCZcyBuZWVkZWQgdG8gY2hhbmdlIHRoZSBsaXN0IG9mIGV2ZW50cywgYmVjYXVzZSBwYXJzaW5nIGNhbiBiZVxuLy8gbWVzc3ksIGFuZCBpdCBoZWxwcyB0byBleHBvc2UgYSBjbGVhbmVyIGludGVyZmFjZSBvZiBldmVudHMgdG8gdGhlIGNvbXBpbGVyXG4vLyBhbmQgb3RoZXIgdXNlcnMuXG4vLyBJdCBjYW4gYWxzbyBoZWxwIHRvIG1lcmdlIG1hbnkgYWRqYWNlbnQgc2ltaWxhciBldmVudHMuXG4vLyBBbmQsIGluIG90aGVyIGNhc2VzLCBpdOKAmXMgbmVlZGVkIHRvIHBhcnNlIHN1YmNvbnRlbnQ6IHBhc3Mgc29tZSBldmVudHNcbi8vIHRocm91Z2ggYW5vdGhlciB0b2tlbml6ZXIgYW5kIGluamVjdCB0aGUgcmVzdWx0LlxuXG4vKipcbiAqIEB0eXBlZGVmIHtbbnVtYmVyLCBudW1iZXIsIEFycmF5PEV2ZW50Pl19IENoYW5nZVxuICogQHR5cGVkZWYge1tudW1iZXIsIG51bWJlciwgbnVtYmVyXX0gSnVtcFxuICovXG5cbi8qKlxuICogVHJhY2tzIGEgYnVuY2ggb2YgZWRpdHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFZGl0TWFwIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBlZGl0IG1hcC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIFJlY29yZCBvZiBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PENoYW5nZT59XG4gICAgICovXG4gICAgdGhpcy5tYXAgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZGl0OiBhIHJlbW92ZSBhbmQvb3IgYWRkIGF0IGEgY2VydGFpbiBwbGFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZW1vdmVcbiAgICogQHBhcmFtIHtBcnJheTxFdmVudD59IGFkZFxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgYWRkKGluZGV4LCByZW1vdmUsIGFkZCkge1xuICAgIGFkZEltcGxlbWVudGF0aW9uKHRoaXMsIGluZGV4LCByZW1vdmUsIGFkZClcbiAgfVxuXG4gIC8vIFRvIGRvOiBhZGQgdGhpcyB3aGVuIG1vdmluZyB0byBgbWljcm9tYXJrYC5cbiAgLy8gLyoqXG4gIC8vICAqIENyZWF0ZSBhbiBlZGl0OiBidXQgaW5zZXJ0IGBhZGRgIGJlZm9yZSBleGlzdGluZyBhZGRpdGlvbnMuXG4gIC8vICAqXG4gIC8vICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAvLyAgKiBAcGFyYW0ge251bWJlcn0gcmVtb3ZlXG4gIC8vICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBhZGRcbiAgLy8gICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgLy8gICovXG4gIC8vIGFkZEJlZm9yZShpbmRleCwgcmVtb3ZlLCBhZGQpIHtcbiAgLy8gICBhZGRJbXBsZW1lbnRhdGlvbih0aGlzLCBpbmRleCwgcmVtb3ZlLCBhZGQsIHRydWUpXG4gIC8vIH1cblxuICAvKipcbiAgICogRG9uZSwgY2hhbmdlIHRoZSBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGNvbnN1bWUoZXZlbnRzKSB7XG4gICAgdGhpcy5tYXAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdXG4gICAgfSlcblxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgLS0gYHJlc29sdmVgIGlzIG5ldmVyIGNhbGxlZCB3aXRob3V0IHRhYmxlcywgc28gd2l0aG91dCBlZGl0cy4gKi9cbiAgICBpZiAodGhpcy5tYXAubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUbyBkbzogaWYgbGlua3MgYXJlIGFkZGVkIGluIGV2ZW50cywgbGlrZSB0aGV5IGFyZSBpbiBgbWFya2Rvd24tcnNgLFxuICAgIC8vIHRoaXMgaXMgbmVlZGVkLlxuICAgIC8vIC8vIENhbGN1bGF0ZSBqdW1wczogd2hlcmUgaXRlbXMgaW4gdGhlIGN1cnJlbnQgbGlzdCBtb3ZlIHRvLlxuICAgIC8vIC8qKiBAdHlwZSB7QXJyYXk8SnVtcD59ICovXG4gICAgLy8gY29uc3QganVtcHMgPSBbXVxuICAgIC8vIGxldCBpbmRleCA9IDBcbiAgICAvLyBsZXQgYWRkQWNjID0gMFxuICAgIC8vIGxldCByZW1vdmVBY2MgPSAwXG4gICAgLy8gd2hpbGUgKGluZGV4IDwgdGhpcy5tYXAubGVuZ3RoKSB7XG4gICAgLy8gICBjb25zdCBbYXQsIHJlbW92ZSwgYWRkXSA9IHRoaXMubWFwW2luZGV4XVxuICAgIC8vICAgcmVtb3ZlQWNjICs9IHJlbW92ZVxuICAgIC8vICAgYWRkQWNjICs9IGFkZC5sZW5ndGhcbiAgICAvLyAgIGp1bXBzLnB1c2goW2F0LCByZW1vdmVBY2MsIGFkZEFjY10pXG4gICAgLy8gICBpbmRleCArPSAxXG4gICAgLy8gfVxuICAgIC8vXG4gICAgLy8gLiBzaGlmdExpbmtzKGV2ZW50cywganVtcHMpXG5cbiAgICBsZXQgaW5kZXggPSB0aGlzLm1hcC5sZW5ndGhcbiAgICAvKiogQHR5cGUge0FycmF5PEFycmF5PEV2ZW50Pj59ICovXG4gICAgY29uc3QgdmVjcyA9IFtdXG4gICAgd2hpbGUgKGluZGV4ID4gMCkge1xuICAgICAgaW5kZXggLT0gMVxuICAgICAgdmVjcy5wdXNoKFxuICAgICAgICBldmVudHMuc2xpY2UodGhpcy5tYXBbaW5kZXhdWzBdICsgdGhpcy5tYXBbaW5kZXhdWzFdKSxcbiAgICAgICAgdGhpcy5tYXBbaW5kZXhdWzJdXG4gICAgICApXG5cbiAgICAgIC8vIFRydW5jYXRlIHJlc3QuXG4gICAgICBldmVudHMubGVuZ3RoID0gdGhpcy5tYXBbaW5kZXhdWzBdXG4gICAgfVxuXG4gICAgdmVjcy5wdXNoKGV2ZW50cy5zbGljZSgpKVxuICAgIGV2ZW50cy5sZW5ndGggPSAwXG5cbiAgICBsZXQgc2xpY2UgPSB2ZWNzLnBvcCgpXG5cbiAgICB3aGlsZSAoc2xpY2UpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBzbGljZSkge1xuICAgICAgICBldmVudHMucHVzaChlbGVtZW50KVxuICAgICAgfVxuXG4gICAgICBzbGljZSA9IHZlY3MucG9wKClcbiAgICB9XG5cbiAgICAvLyBUcnVuY2F0ZSBldmVyeXRoaW5nLlxuICAgIHRoaXMubWFwLmxlbmd0aCA9IDBcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlZGl0LlxuICpcbiAqIEBwYXJhbSB7RWRpdE1hcH0gZWRpdE1hcFxuICogQHBhcmFtIHtudW1iZXJ9IGF0XG4gKiBAcGFyYW0ge251bWJlcn0gcmVtb3ZlXG4gKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gYWRkXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBhZGRJbXBsZW1lbnRhdGlvbihlZGl0TWFwLCBhdCwgcmVtb3ZlLCBhZGQpIHtcbiAgbGV0IGluZGV4ID0gMFxuXG4gIC8qIGM4IGlnbm9yZSBuZXh0IDMgLS0gYHJlc29sdmVgIGlzIG5ldmVyIGNhbGxlZCB3aXRob3V0IHRhYmxlcywgc28gd2l0aG91dCBlZGl0cy4gKi9cbiAgaWYgKHJlbW92ZSA9PT0gMCAmJiBhZGQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB3aGlsZSAoaW5kZXggPCBlZGl0TWFwLm1hcC5sZW5ndGgpIHtcbiAgICBpZiAoZWRpdE1hcC5tYXBbaW5kZXhdWzBdID09PSBhdCkge1xuICAgICAgZWRpdE1hcC5tYXBbaW5kZXhdWzFdICs9IHJlbW92ZVxuXG4gICAgICAvLyBUbyBkbzogYmVmb3JlIG5vdCB1c2VkIGJ5IHRhYmxlcywgdXNlIHdoZW4gbW92aW5nIHRvIG1pY3JvbWFyay5cbiAgICAgIC8vIGlmIChiZWZvcmUpIHtcbiAgICAgIC8vICAgYWRkLnB1c2goLi4uZWRpdE1hcC5tYXBbaW5kZXhdWzJdKVxuICAgICAgLy8gICBlZGl0TWFwLm1hcFtpbmRleF1bMl0gPSBhZGRcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICBlZGl0TWFwLm1hcFtpbmRleF1bMl0ucHVzaCguLi5hZGQpXG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGluZGV4ICs9IDFcbiAgfVxuXG4gIGVkaXRNYXAubWFwLnB1c2goW2F0LCByZW1vdmUsIGFkZF0pXG59XG5cbi8vIC8qKlxuLy8gICogU2hpZnQgYHByZXZpb3VzYCBhbmQgYG5leHRgIGxpbmtzIGFjY29yZGluZyB0byBganVtcHNgLlxuLy8gICpcbi8vICAqIFRoaXMgZml4ZXMgbGlua3MgaW4gY2FzZSB0aGVyZSBhcmUgZXZlbnRzIHJlbW92ZWQgb3IgYWRkZWQgYmV0d2VlbiB0aGVtLlxuLy8gICpcbi8vICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbi8vICAqIEBwYXJhbSB7QXJyYXk8SnVtcD59IGp1bXBzXG4vLyAgKi9cbi8vIGZ1bmN0aW9uIHNoaWZ0TGlua3MoZXZlbnRzLCBqdW1wcykge1xuLy8gICBsZXQganVtcEluZGV4ID0gMFxuLy8gICBsZXQgaW5kZXggPSAwXG4vLyAgIGxldCBhZGQgPSAwXG4vLyAgIGxldCBybSA9IDBcblxuLy8gICB3aGlsZSAoaW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4vLyAgICAgY29uc3Qgcm1DdXJyID0gcm1cblxuLy8gICAgIHdoaWxlIChqdW1wSW5kZXggPCBqdW1wcy5sZW5ndGggJiYganVtcHNbanVtcEluZGV4XVswXSA8PSBpbmRleCkge1xuLy8gICAgICAgYWRkID0ganVtcHNbanVtcEluZGV4XVsyXVxuLy8gICAgICAgcm0gPSBqdW1wc1tqdW1wSW5kZXhdWzFdXG4vLyAgICAgICBqdW1wSW5kZXggKz0gMVxuLy8gICAgIH1cblxuLy8gICAgIC8vIElnbm9yZSBpdGVtcyB0aGF0IHdpbGwgYmUgcmVtb3ZlZC5cbi8vICAgICBpZiAocm0gPiBybUN1cnIpIHtcbi8vICAgICAgIGluZGV4ICs9IHJtIC0gcm1DdXJyXG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIC8vID9cbi8vICAgICAgIC8vIGlmIGxldCBTb21lKGxpbmspID0gJmV2ZW50c1tpbmRleF0ubGluayB7XG4vLyAgICAgICAvLyAgICAgaWYgbGV0IFNvbWUobmV4dCkgPSBsaW5rLm5leHQge1xuLy8gICAgICAgLy8gICAgICAgICBldmVudHNbbmV4dF0ubGluay5hc19tdXQoKS51bndyYXAoKS5wcmV2aW91cyA9IFNvbWUoaW5kZXggKyBhZGQgLSBybSk7XG4vLyAgICAgICAvLyAgICAgICAgIHdoaWxlIGp1bXBJbmRleCA8IGp1bXBzLmxlbigpICYmIGp1bXBzW2p1bXBJbmRleF0uMCA8PSBuZXh0IHtcbi8vICAgICAgIC8vICAgICAgICAgICAgIGFkZCA9IGp1bXBzW2p1bXBJbmRleF0uMjtcbi8vICAgICAgIC8vICAgICAgICAgICAgIHJtID0ganVtcHNbanVtcEluZGV4XS4xO1xuLy8gICAgICAgLy8gICAgICAgICAgICAganVtcEluZGV4ICs9IDE7XG4vLyAgICAgICAvLyAgICAgICAgIH1cbi8vICAgICAgIC8vICAgICAgICAgZXZlbnRzW2luZGV4XS5saW5rLmFzX211dCgpLnVud3JhcCgpLm5leHQgPSBTb21lKG5leHQgKyBhZGQgLSBybSk7XG4vLyAgICAgICAvLyAgICAgICAgIGluZGV4ID0gbmV4dDtcbi8vICAgICAgIC8vICAgICAgICAgY29udGludWU7XG4vLyAgICAgICAvLyAgICAgfVxuLy8gICAgICAgLy8gfVxuLy8gICAgICAgaW5kZXggKz0gMVxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuIl0sIm5hbWVzIjpbIkVkaXRNYXAiLCJjb25zdHJ1Y3RvciIsIm1hcCIsImFkZCIsImluZGV4IiwicmVtb3ZlIiwiYWRkSW1wbGVtZW50YXRpb24iLCJjb25zdW1lIiwiZXZlbnRzIiwic29ydCIsImEiLCJiIiwibGVuZ3RoIiwidmVjcyIsInB1c2giLCJzbGljZSIsInBvcCIsImVsZW1lbnQiLCJlZGl0TWFwIiwiYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/html.js":
/*!********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/html.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTableHtml: () => (/* binding */ gfmTableHtml)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/**\n * @import {HtmlExtension} from 'micromark-util-types'\n */ \nconst alignment = {\n    none: \"\",\n    left: ' align=\"left\"',\n    right: ' align=\"right\"',\n    center: ' align=\"center\"'\n};\n// To do: micromark@5: use `infer` here, when all events are exposed.\n/**\n * Create an HTML extension for `micromark` to support GitHub tables when\n * serializing to HTML.\n *\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GitHub tables when serializing to HTML.\n */ function gfmTableHtml() {\n    return {\n        enter: {\n            table (token) {\n                const tableAlign = token._align;\n                (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `_align`\");\n                this.lineEndingIfNeeded();\n                this.tag(\"<table>\");\n                this.setData(\"tableAlign\", tableAlign);\n            },\n            tableBody () {\n                this.tag(\"<tbody>\");\n            },\n            tableData () {\n                const tableAlign = this.getData(\"tableAlign\");\n                const tableColumn = this.getData(\"tableColumn\");\n                (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n                (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n                const align = alignment[tableAlign[tableColumn]];\n                if (align === undefined) {\n                    // Capture results to ignore them.\n                    this.buffer();\n                } else {\n                    this.lineEndingIfNeeded();\n                    this.tag(\"<td\" + align + \">\");\n                }\n            },\n            tableHead () {\n                this.lineEndingIfNeeded();\n                this.tag(\"<thead>\");\n            },\n            tableHeader () {\n                const tableAlign = this.getData(\"tableAlign\");\n                const tableColumn = this.getData(\"tableColumn\");\n                (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n                (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n                const align = alignment[tableAlign[tableColumn]];\n                this.lineEndingIfNeeded();\n                this.tag(\"<th\" + align + \">\");\n            },\n            tableRow () {\n                this.setData(\"tableColumn\", 0);\n                this.lineEndingIfNeeded();\n                this.tag(\"<tr>\");\n            }\n        },\n        exit: {\n            // Overwrite the default code text data handler to unescape escaped pipes when\n            // they are in tables.\n            codeTextData (token) {\n                let value = this.sliceSerialize(token);\n                if (this.getData(\"tableAlign\")) {\n                    value = value.replace(/\\\\([\\\\|])/g, replace);\n                }\n                this.raw(this.encode(value));\n            },\n            table () {\n                this.setData(\"tableAlign\");\n                // Note: we don’t set `slurpAllLineEndings` anymore, in delimiter rows,\n                // but we do need to reset it to match a funky newline GH generates for\n                // list items combined with tables.\n                this.setData(\"slurpAllLineEndings\");\n                this.lineEndingIfNeeded();\n                this.tag(\"</table>\");\n            },\n            tableBody () {\n                this.lineEndingIfNeeded();\n                this.tag(\"</tbody>\");\n            },\n            tableData () {\n                const tableAlign = this.getData(\"tableAlign\");\n                const tableColumn = this.getData(\"tableColumn\");\n                (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n                (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n                if (tableColumn in tableAlign) {\n                    this.tag(\"</td>\");\n                    this.setData(\"tableColumn\", tableColumn + 1);\n                } else {\n                    // Stop capturing.\n                    this.resume();\n                }\n            },\n            tableHead () {\n                this.lineEndingIfNeeded();\n                this.tag(\"</thead>\");\n            },\n            tableHeader () {\n                const tableColumn = this.getData(\"tableColumn\");\n                (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n                this.tag(\"</th>\");\n                this.setData(\"tableColumn\", tableColumn + 1);\n            },\n            tableRow () {\n                const tableAlign = this.getData(\"tableAlign\");\n                let tableColumn = this.getData(\"tableColumn\");\n                (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, \"expected `tableAlign`\");\n                (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === \"number\", \"expected `tableColumn`\");\n                while(tableColumn < tableAlign.length){\n                    this.lineEndingIfNeeded();\n                    this.tag(\"<td\" + alignment[tableAlign[tableColumn]] + \"></td>\");\n                    tableColumn++;\n                }\n                this.setData(\"tableColumn\", tableColumn);\n                this.lineEndingIfNeeded();\n                this.tag(\"</tr>\");\n            }\n        }\n    };\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */ function replace($0, $1) {\n    // Pipes work, backslashes don’t (but can’t escape pipes).\n    return $1 === \"|\" ? $1 : $0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9odG1sLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0NBRUMsR0FFa0M7QUFFbkMsTUFBTUUsWUFBWTtJQUNoQkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtBQUNWO0FBRUEscUVBQXFFO0FBRXJFOzs7Ozs7O0NBT0MsR0FDTSxTQUFTQztJQUNkLE9BQU87UUFDTEMsT0FBTztZQUNMQyxPQUFNQyxLQUFLO2dCQUNULE1BQU1DLGFBQWFELE1BQU1FLE1BQU07Z0JBQy9CWCwwQ0FBTUEsQ0FBQ1UsWUFBWTtnQkFDbkIsSUFBSSxDQUFDRSxrQkFBa0I7Z0JBQ3ZCLElBQUksQ0FBQ0MsR0FBRyxDQUFDO2dCQUNULElBQUksQ0FBQ0MsT0FBTyxDQUFDLGNBQWNKO1lBQzdCO1lBQ0FLO2dCQUNFLElBQUksQ0FBQ0YsR0FBRyxDQUFDO1lBQ1g7WUFDQUc7Z0JBQ0UsTUFBTU4sYUFBYSxJQUFJLENBQUNPLE9BQU8sQ0FBQztnQkFDaEMsTUFBTUMsY0FBYyxJQUFJLENBQUNELE9BQU8sQ0FBQztnQkFDakNqQiwwQ0FBTUEsQ0FBQ1UsWUFBWTtnQkFDbkJWLDBDQUFNQSxDQUFDLE9BQU9rQixnQkFBZ0IsVUFBVTtnQkFDeEMsTUFBTUMsUUFBUWxCLFNBQVMsQ0FBQ1MsVUFBVSxDQUFDUSxZQUFZLENBQUM7Z0JBRWhELElBQUlDLFVBQVVDLFdBQVc7b0JBQ3ZCLGtDQUFrQztvQkFDbEMsSUFBSSxDQUFDQyxNQUFNO2dCQUNiLE9BQU87b0JBQ0wsSUFBSSxDQUFDVCxrQkFBa0I7b0JBQ3ZCLElBQUksQ0FBQ0MsR0FBRyxDQUFDLFFBQVFNLFFBQVE7Z0JBQzNCO1lBQ0Y7WUFDQUc7Z0JBQ0UsSUFBSSxDQUFDVixrQkFBa0I7Z0JBQ3ZCLElBQUksQ0FBQ0MsR0FBRyxDQUFDO1lBQ1g7WUFDQVU7Z0JBQ0UsTUFBTWIsYUFBYSxJQUFJLENBQUNPLE9BQU8sQ0FBQztnQkFDaEMsTUFBTUMsY0FBYyxJQUFJLENBQUNELE9BQU8sQ0FBQztnQkFDakNqQiwwQ0FBTUEsQ0FBQ1UsWUFBWTtnQkFDbkJWLDBDQUFNQSxDQUFDLE9BQU9rQixnQkFBZ0IsVUFBVTtnQkFDeEMsTUFBTUMsUUFBUWxCLFNBQVMsQ0FBQ1MsVUFBVSxDQUFDUSxZQUFZLENBQUM7Z0JBQ2hELElBQUksQ0FBQ04sa0JBQWtCO2dCQUN2QixJQUFJLENBQUNDLEdBQUcsQ0FBQyxRQUFRTSxRQUFRO1lBQzNCO1lBQ0FLO2dCQUNFLElBQUksQ0FBQ1YsT0FBTyxDQUFDLGVBQWU7Z0JBQzVCLElBQUksQ0FBQ0Ysa0JBQWtCO2dCQUN2QixJQUFJLENBQUNDLEdBQUcsQ0FBQztZQUNYO1FBQ0Y7UUFDQVksTUFBTTtZQUNKLDhFQUE4RTtZQUM5RSxzQkFBc0I7WUFDdEJDLGNBQWFqQixLQUFLO2dCQUNoQixJQUFJa0IsUUFBUSxJQUFJLENBQUNDLGNBQWMsQ0FBQ25CO2dCQUVoQyxJQUFJLElBQUksQ0FBQ1EsT0FBTyxDQUFDLGVBQWU7b0JBQzlCVSxRQUFRQSxNQUFNRSxPQUFPLENBQUMsY0FBY0E7Z0JBQ3RDO2dCQUVBLElBQUksQ0FBQ0MsR0FBRyxDQUFDLElBQUksQ0FBQ0MsTUFBTSxDQUFDSjtZQUN2QjtZQUNBbkI7Z0JBQ0UsSUFBSSxDQUFDTSxPQUFPLENBQUM7Z0JBQ2IsdUVBQXVFO2dCQUN2RSx1RUFBdUU7Z0JBQ3ZFLG1DQUFtQztnQkFDbkMsSUFBSSxDQUFDQSxPQUFPLENBQUM7Z0JBQ2IsSUFBSSxDQUFDRixrQkFBa0I7Z0JBQ3ZCLElBQUksQ0FBQ0MsR0FBRyxDQUFDO1lBQ1g7WUFDQUU7Z0JBQ0UsSUFBSSxDQUFDSCxrQkFBa0I7Z0JBQ3ZCLElBQUksQ0FBQ0MsR0FBRyxDQUFDO1lBQ1g7WUFDQUc7Z0JBQ0UsTUFBTU4sYUFBYSxJQUFJLENBQUNPLE9BQU8sQ0FBQztnQkFDaEMsTUFBTUMsY0FBYyxJQUFJLENBQUNELE9BQU8sQ0FBQztnQkFDakNqQiwwQ0FBTUEsQ0FBQ1UsWUFBWTtnQkFDbkJWLDBDQUFNQSxDQUFDLE9BQU9rQixnQkFBZ0IsVUFBVTtnQkFFeEMsSUFBSUEsZUFBZVIsWUFBWTtvQkFDN0IsSUFBSSxDQUFDRyxHQUFHLENBQUM7b0JBQ1QsSUFBSSxDQUFDQyxPQUFPLENBQUMsZUFBZUksY0FBYztnQkFDNUMsT0FBTztvQkFDTCxrQkFBa0I7b0JBQ2xCLElBQUksQ0FBQ2MsTUFBTTtnQkFDYjtZQUNGO1lBQ0FWO2dCQUNFLElBQUksQ0FBQ1Ysa0JBQWtCO2dCQUN2QixJQUFJLENBQUNDLEdBQUcsQ0FBQztZQUNYO1lBQ0FVO2dCQUNFLE1BQU1MLGNBQWMsSUFBSSxDQUFDRCxPQUFPLENBQUM7Z0JBQ2pDakIsMENBQU1BLENBQUMsT0FBT2tCLGdCQUFnQixVQUFVO2dCQUN4QyxJQUFJLENBQUNMLEdBQUcsQ0FBQztnQkFDVCxJQUFJLENBQUNDLE9BQU8sQ0FBQyxlQUFlSSxjQUFjO1lBQzVDO1lBQ0FNO2dCQUNFLE1BQU1kLGFBQWEsSUFBSSxDQUFDTyxPQUFPLENBQUM7Z0JBQ2hDLElBQUlDLGNBQWMsSUFBSSxDQUFDRCxPQUFPLENBQUM7Z0JBQy9CakIsMENBQU1BLENBQUNVLFlBQVk7Z0JBQ25CViwwQ0FBTUEsQ0FBQyxPQUFPa0IsZ0JBQWdCLFVBQVU7Z0JBRXhDLE1BQU9BLGNBQWNSLFdBQVd1QixNQUFNLENBQUU7b0JBQ3RDLElBQUksQ0FBQ3JCLGtCQUFrQjtvQkFDdkIsSUFBSSxDQUFDQyxHQUFHLENBQUMsUUFBUVosU0FBUyxDQUFDUyxVQUFVLENBQUNRLFlBQVksQ0FBQyxHQUFHO29CQUN0REE7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDSixPQUFPLENBQUMsZUFBZUk7Z0JBQzVCLElBQUksQ0FBQ04sa0JBQWtCO2dCQUN2QixJQUFJLENBQUNDLEdBQUcsQ0FBQztZQUNYO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNnQixRQUFRSyxFQUFFLEVBQUVDLEVBQUU7SUFDckIsMERBQTBEO0lBQzFELE9BQU9BLE9BQU8sTUFBTUEsS0FBS0Q7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaWVsLXN0dWRpby8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL2h0bWwuanM/ZWE2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0h0bWxFeHRlbnNpb259IGZyb20gJ21pY3JvbWFyay11dGlsLXR5cGVzJ1xuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5cbmNvbnN0IGFsaWdubWVudCA9IHtcbiAgbm9uZTogJycsXG4gIGxlZnQ6ICcgYWxpZ249XCJsZWZ0XCInLFxuICByaWdodDogJyBhbGlnbj1cInJpZ2h0XCInLFxuICBjZW50ZXI6ICcgYWxpZ249XCJjZW50ZXJcIidcbn1cblxuLy8gVG8gZG86IG1pY3JvbWFya0A1OiB1c2UgYGluZmVyYCBoZXJlLCB3aGVuIGFsbCBldmVudHMgYXJlIGV4cG9zZWQuXG5cbi8qKlxuICogQ3JlYXRlIGFuIEhUTUwgZXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0byBzdXBwb3J0IEdpdEh1YiB0YWJsZXMgd2hlblxuICogc2VyaWFsaXppbmcgdG8gSFRNTC5cbiAqXG4gKiBAcmV0dXJucyB7SHRtbEV4dGVuc2lvbn1cbiAqICAgRXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0aGF0IGNhbiBiZSBwYXNzZWQgaW4gYGh0bWxFeHRlbnNpb25zYCB0b1xuICogICBzdXBwb3J0IEdpdEh1YiB0YWJsZXMgd2hlbiBzZXJpYWxpemluZyB0byBIVE1MLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtVGFibGVIdG1sKCkge1xuICByZXR1cm4ge1xuICAgIGVudGVyOiB7XG4gICAgICB0YWJsZSh0b2tlbikge1xuICAgICAgICBjb25zdCB0YWJsZUFsaWduID0gdG9rZW4uX2FsaWduXG4gICAgICAgIGFzc2VydCh0YWJsZUFsaWduLCAnZXhwZWN0ZWQgYF9hbGlnbmAnKVxuICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgIHRoaXMudGFnKCc8dGFibGU+JylcbiAgICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUFsaWduJywgdGFibGVBbGlnbilcbiAgICAgIH0sXG4gICAgICB0YWJsZUJvZHkoKSB7XG4gICAgICAgIHRoaXMudGFnKCc8dGJvZHk+JylcbiAgICAgIH0sXG4gICAgICB0YWJsZURhdGEoKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlQWxpZ24gPSB0aGlzLmdldERhdGEoJ3RhYmxlQWxpZ24nKVxuICAgICAgICBjb25zdCB0YWJsZUNvbHVtbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKVxuICAgICAgICBhc3NlcnQodGFibGVBbGlnbiwgJ2V4cGVjdGVkIGB0YWJsZUFsaWduYCcpXG4gICAgICAgIGFzc2VydCh0eXBlb2YgdGFibGVDb2x1bW4gPT09ICdudW1iZXInLCAnZXhwZWN0ZWQgYHRhYmxlQ29sdW1uYCcpXG4gICAgICAgIGNvbnN0IGFsaWduID0gYWxpZ25tZW50W3RhYmxlQWxpZ25bdGFibGVDb2x1bW5dXVxuXG4gICAgICAgIGlmIChhbGlnbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gQ2FwdHVyZSByZXN1bHRzIHRvIGlnbm9yZSB0aGVtLlxuICAgICAgICAgIHRoaXMuYnVmZmVyKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgICAgdGhpcy50YWcoJzx0ZCcgKyBhbGlnbiArICc+JylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRhYmxlSGVhZCgpIHtcbiAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICB0aGlzLnRhZygnPHRoZWFkPicpXG4gICAgICB9LFxuICAgICAgdGFibGVIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlQWxpZ24gPSB0aGlzLmdldERhdGEoJ3RhYmxlQWxpZ24nKVxuICAgICAgICBjb25zdCB0YWJsZUNvbHVtbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKVxuICAgICAgICBhc3NlcnQodGFibGVBbGlnbiwgJ2V4cGVjdGVkIGB0YWJsZUFsaWduYCcpXG4gICAgICAgIGFzc2VydCh0eXBlb2YgdGFibGVDb2x1bW4gPT09ICdudW1iZXInLCAnZXhwZWN0ZWQgYHRhYmxlQ29sdW1uYCcpXG4gICAgICAgIGNvbnN0IGFsaWduID0gYWxpZ25tZW50W3RhYmxlQWxpZ25bdGFibGVDb2x1bW5dXVxuICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgIHRoaXMudGFnKCc8dGgnICsgYWxpZ24gKyAnPicpXG4gICAgICB9LFxuICAgICAgdGFibGVSb3coKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YSgndGFibGVDb2x1bW4nLCAwKVxuICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgIHRoaXMudGFnKCc8dHI+JylcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBjb2RlIHRleHQgZGF0YSBoYW5kbGVyIHRvIHVuZXNjYXBlIGVzY2FwZWQgcGlwZXMgd2hlblxuICAgICAgLy8gdGhleSBhcmUgaW4gdGFibGVzLlxuICAgICAgY29kZVRleHREYXRhKHRva2VuKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0RGF0YSgndGFibGVBbGlnbicpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcKFtcXFxcfF0pL2csIHJlcGxhY2UpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJhdyh0aGlzLmVuY29kZSh2YWx1ZSkpXG4gICAgICB9LFxuICAgICAgdGFibGUoKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YSgndGFibGVBbGlnbicpXG4gICAgICAgIC8vIE5vdGU6IHdlIGRvbuKAmXQgc2V0IGBzbHVycEFsbExpbmVFbmRpbmdzYCBhbnltb3JlLCBpbiBkZWxpbWl0ZXIgcm93cyxcbiAgICAgICAgLy8gYnV0IHdlIGRvIG5lZWQgdG8gcmVzZXQgaXQgdG8gbWF0Y2ggYSBmdW5reSBuZXdsaW5lIEdIIGdlbmVyYXRlcyBmb3JcbiAgICAgICAgLy8gbGlzdCBpdGVtcyBjb21iaW5lZCB3aXRoIHRhYmxlcy5cbiAgICAgICAgdGhpcy5zZXREYXRhKCdzbHVycEFsbExpbmVFbmRpbmdzJylcbiAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICB0aGlzLnRhZygnPC90YWJsZT4nKVxuICAgICAgfSxcbiAgICAgIHRhYmxlQm9keSgpIHtcbiAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICB0aGlzLnRhZygnPC90Ym9keT4nKVxuICAgICAgfSxcbiAgICAgIHRhYmxlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgdGFibGVBbGlnbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVBbGlnbicpXG4gICAgICAgIGNvbnN0IHRhYmxlQ29sdW1uID0gdGhpcy5nZXREYXRhKCd0YWJsZUNvbHVtbicpXG4gICAgICAgIGFzc2VydCh0YWJsZUFsaWduLCAnZXhwZWN0ZWQgYHRhYmxlQWxpZ25gJylcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB0YWJsZUNvbHVtbiA9PT0gJ251bWJlcicsICdleHBlY3RlZCBgdGFibGVDb2x1bW5gJylcblxuICAgICAgICBpZiAodGFibGVDb2x1bW4gaW4gdGFibGVBbGlnbikge1xuICAgICAgICAgIHRoaXMudGFnKCc8L3RkPicpXG4gICAgICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUNvbHVtbicsIHRhYmxlQ29sdW1uICsgMSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTdG9wIGNhcHR1cmluZy5cbiAgICAgICAgICB0aGlzLnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0YWJsZUhlYWQoKSB7XG4gICAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgICAgdGhpcy50YWcoJzwvdGhlYWQ+JylcbiAgICAgIH0sXG4gICAgICB0YWJsZUhlYWRlcigpIHtcbiAgICAgICAgY29uc3QgdGFibGVDb2x1bW4gPSB0aGlzLmdldERhdGEoJ3RhYmxlQ29sdW1uJylcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB0YWJsZUNvbHVtbiA9PT0gJ251bWJlcicsICdleHBlY3RlZCBgdGFibGVDb2x1bW5gJylcbiAgICAgICAgdGhpcy50YWcoJzwvdGg+JylcbiAgICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUNvbHVtbicsIHRhYmxlQ29sdW1uICsgMSlcbiAgICAgIH0sXG4gICAgICB0YWJsZVJvdygpIHtcbiAgICAgICAgY29uc3QgdGFibGVBbGlnbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVBbGlnbicpXG4gICAgICAgIGxldCB0YWJsZUNvbHVtbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKVxuICAgICAgICBhc3NlcnQodGFibGVBbGlnbiwgJ2V4cGVjdGVkIGB0YWJsZUFsaWduYCcpXG4gICAgICAgIGFzc2VydCh0eXBlb2YgdGFibGVDb2x1bW4gPT09ICdudW1iZXInLCAnZXhwZWN0ZWQgYHRhYmxlQ29sdW1uYCcpXG5cbiAgICAgICAgd2hpbGUgKHRhYmxlQ29sdW1uIDwgdGFibGVBbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgICAgdGhpcy50YWcoJzx0ZCcgKyBhbGlnbm1lbnRbdGFibGVBbGlnblt0YWJsZUNvbHVtbl1dICsgJz48L3RkPicpXG4gICAgICAgICAgdGFibGVDb2x1bW4rK1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUNvbHVtbicsIHRhYmxlQ29sdW1uKVxuICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgIHRoaXMudGFnKCc8L3RyPicpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9ICQwXG4gKiBAcGFyYW0ge3N0cmluZ30gJDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2UoJDAsICQxKSB7XG4gIC8vIFBpcGVzIHdvcmssIGJhY2tzbGFzaGVzIGRvbuKAmXQgKGJ1dCBjYW7igJl0IGVzY2FwZSBwaXBlcykuXG4gIHJldHVybiAkMSA9PT0gJ3wnID8gJDEgOiAkMFxufVxuIl0sIm5hbWVzIjpbIm9rIiwiYXNzZXJ0IiwiYWxpZ25tZW50Iiwibm9uZSIsImxlZnQiLCJyaWdodCIsImNlbnRlciIsImdmbVRhYmxlSHRtbCIsImVudGVyIiwidGFibGUiLCJ0b2tlbiIsInRhYmxlQWxpZ24iLCJfYWxpZ24iLCJsaW5lRW5kaW5nSWZOZWVkZWQiLCJ0YWciLCJzZXREYXRhIiwidGFibGVCb2R5IiwidGFibGVEYXRhIiwiZ2V0RGF0YSIsInRhYmxlQ29sdW1uIiwiYWxpZ24iLCJ1bmRlZmluZWQiLCJidWZmZXIiLCJ0YWJsZUhlYWQiLCJ0YWJsZUhlYWRlciIsInRhYmxlUm93IiwiZXhpdCIsImNvZGVUZXh0RGF0YSIsInZhbHVlIiwic2xpY2VTZXJpYWxpemUiLCJyZXBsYWNlIiwicmF3IiwiZW5jb2RlIiwicmVzdW1lIiwibGVuZ3RoIiwiJDAiLCIkMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/html.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/infer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTableAlign: () => (/* binding */ gfmTableAlign)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/**\n * @import {Event} from 'micromark-util-types'\n */ /**\n * @typedef {'center' | 'left' | 'none' | 'right'} Align\n */ \n/**\n * Figure out the alignment of a GFM table.\n *\n * @param {Readonly<Array<Event>>} events\n *   List of events.\n * @param {number} index\n *   Table enter event.\n * @returns {Array<Align>}\n *   List of aligns.\n */ function gfmTableAlign(events, index) {\n    (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(events[index][1].type === \"table\", \"expected table\");\n    let inDelimiterRow = false;\n    /** @type {Array<Align>} */ const align = [];\n    while(index < events.length){\n        const event = events[index];\n        if (inDelimiterRow) {\n            if (event[0] === \"enter\") {\n                // Start of alignment value: set a new column.\n                // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n                if (event[1].type === \"tableContent\") {\n                    align.push(events[index + 1][1].type === \"tableDelimiterMarker\" ? \"left\" : \"none\");\n                }\n            } else if (event[1].type === \"tableContent\") {\n                if (events[index - 1][1].type === \"tableDelimiterMarker\") {\n                    const alignIndex = align.length - 1;\n                    align[alignIndex] = align[alignIndex] === \"left\" ? \"center\" : \"right\";\n                }\n            } else if (event[1].type === \"tableDelimiterRow\") {\n                break;\n            }\n        } else if (event[0] === \"enter\" && event[1].type === \"tableDelimiterRow\") {\n            inDelimiterRow = true;\n        }\n        index += 1;\n    }\n    return align;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9pbmZlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztDQUVDLEdBRUQ7O0NBRUMsR0FFa0M7QUFFbkM7Ozs7Ozs7OztDQVNDLEdBQ00sU0FBU0UsY0FBY0MsTUFBTSxFQUFFQyxLQUFLO0lBQ3pDSCwwQ0FBTUEsQ0FBQ0UsTUFBTSxDQUFDQyxNQUFNLENBQUMsRUFBRSxDQUFDQyxJQUFJLEtBQUssU0FBUztJQUMxQyxJQUFJQyxpQkFBaUI7SUFDckIseUJBQXlCLEdBQ3pCLE1BQU1DLFFBQVEsRUFBRTtJQUVoQixNQUFPSCxRQUFRRCxPQUFPSyxNQUFNLENBQUU7UUFDNUIsTUFBTUMsUUFBUU4sTUFBTSxDQUFDQyxNQUFNO1FBRTNCLElBQUlFLGdCQUFnQjtZQUNsQixJQUFJRyxLQUFLLENBQUMsRUFBRSxLQUFLLFNBQVM7Z0JBQ3hCLDhDQUE4QztnQkFDOUMsdURBQXVEO2dCQUN2RCxJQUFJQSxLQUFLLENBQUMsRUFBRSxDQUFDSixJQUFJLEtBQUssZ0JBQWdCO29CQUNwQ0UsTUFBTUcsSUFBSSxDQUNSUCxNQUFNLENBQUNDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxLQUFLLHlCQUMxQixTQUNBO2dCQUVSO1lBQ0YsT0FJSyxJQUFJSSxLQUFLLENBQUMsRUFBRSxDQUFDSixJQUFJLEtBQUssZ0JBQWdCO2dCQUN6QyxJQUFJRixNQUFNLENBQUNDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxLQUFLLHdCQUF3QjtvQkFDeEQsTUFBTU0sYUFBYUosTUFBTUMsTUFBTSxHQUFHO29CQUVsQ0QsS0FBSyxDQUFDSSxXQUFXLEdBQUdKLEtBQUssQ0FBQ0ksV0FBVyxLQUFLLFNBQVMsV0FBVztnQkFDaEU7WUFDRixPQUVLLElBQUlGLEtBQUssQ0FBQyxFQUFFLENBQUNKLElBQUksS0FBSyxxQkFBcUI7Z0JBQzlDO1lBQ0Y7UUFDRixPQUFPLElBQUlJLEtBQUssQ0FBQyxFQUFFLEtBQUssV0FBV0EsS0FBSyxDQUFDLEVBQUUsQ0FBQ0osSUFBSSxLQUFLLHFCQUFxQjtZQUN4RUMsaUJBQWlCO1FBQ25CO1FBRUFGLFNBQVM7SUFDWDtJQUVBLE9BQU9HO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaWVsLXN0dWRpby8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL2luZmVyLmpzPzUxNjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtFdmVudH0gZnJvbSAnbWljcm9tYXJrLXV0aWwtdHlwZXMnXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J2NlbnRlcicgfCAnbGVmdCcgfCAnbm9uZScgfCAncmlnaHQnfSBBbGlnblxuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5cbi8qKlxuICogRmlndXJlIG91dCB0aGUgYWxpZ25tZW50IG9mIGEgR0ZNIHRhYmxlLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHk8QXJyYXk8RXZlbnQ+Pn0gZXZlbnRzXG4gKiAgIExpc3Qgb2YgZXZlbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiAgIFRhYmxlIGVudGVyIGV2ZW50LlxuICogQHJldHVybnMge0FycmF5PEFsaWduPn1cbiAqICAgTGlzdCBvZiBhbGlnbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1UYWJsZUFsaWduKGV2ZW50cywgaW5kZXgpIHtcbiAgYXNzZXJ0KGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gJ3RhYmxlJywgJ2V4cGVjdGVkIHRhYmxlJylcbiAgbGV0IGluRGVsaW1pdGVyUm93ID0gZmFsc2VcbiAgLyoqIEB0eXBlIHtBcnJheTxBbGlnbj59ICovXG4gIGNvbnN0IGFsaWduID0gW11cblxuICB3aGlsZSAoaW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXhdXG5cbiAgICBpZiAoaW5EZWxpbWl0ZXJSb3cpIHtcbiAgICAgIGlmIChldmVudFswXSA9PT0gJ2VudGVyJykge1xuICAgICAgICAvLyBTdGFydCBvZiBhbGlnbm1lbnQgdmFsdWU6IHNldCBhIG5ldyBjb2x1bW4uXG4gICAgICAgIC8vIFRvIGRvOiBgbWFya2Rvd24tcnNgIHVzZXMgYHRhYmxlRGVsaW1pdGVyQ2VsbFZhbHVlYC5cbiAgICAgICAgaWYgKGV2ZW50WzFdLnR5cGUgPT09ICd0YWJsZUNvbnRlbnQnKSB7XG4gICAgICAgICAgYWxpZ24ucHVzaChcbiAgICAgICAgICAgIGV2ZW50c1tpbmRleCArIDFdWzFdLnR5cGUgPT09ICd0YWJsZURlbGltaXRlck1hcmtlcidcbiAgICAgICAgICAgICAgPyAnbGVmdCdcbiAgICAgICAgICAgICAgOiAnbm9uZSdcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEV4aXRzOlxuICAgICAgLy8gRW5kIG9mIGFsaWdubWVudCB2YWx1ZTogY2hhbmdlIHRoZSBjb2x1bW4uXG4gICAgICAvLyBUbyBkbzogYG1hcmtkb3duLXJzYCB1c2VzIGB0YWJsZURlbGltaXRlckNlbGxWYWx1ZWAuXG4gICAgICBlbHNlIGlmIChldmVudFsxXS50eXBlID09PSAndGFibGVDb250ZW50Jykge1xuICAgICAgICBpZiAoZXZlbnRzW2luZGV4IC0gMV1bMV0udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyTWFya2VyJykge1xuICAgICAgICAgIGNvbnN0IGFsaWduSW5kZXggPSBhbGlnbi5sZW5ndGggLSAxXG5cbiAgICAgICAgICBhbGlnblthbGlnbkluZGV4XSA9IGFsaWduW2FsaWduSW5kZXhdID09PSAnbGVmdCcgPyAnY2VudGVyJyA6ICdyaWdodCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG9uZSFcbiAgICAgIGVsc2UgaWYgKGV2ZW50WzFdLnR5cGUgPT09ICd0YWJsZURlbGltaXRlclJvdycpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInICYmIGV2ZW50WzFdLnR5cGUgPT09ICd0YWJsZURlbGltaXRlclJvdycpIHtcbiAgICAgIGluRGVsaW1pdGVyUm93ID0gdHJ1ZVxuICAgIH1cblxuICAgIGluZGV4ICs9IDFcbiAgfVxuXG4gIHJldHVybiBhbGlnblxufVxuIl0sIm5hbWVzIjpbIm9rIiwiYXNzZXJ0IiwiZ2ZtVGFibGVBbGlnbiIsImV2ZW50cyIsImluZGV4IiwidHlwZSIsImluRGVsaW1pdGVyUm93IiwiYWxpZ24iLCJsZW5ndGgiLCJldmVudCIsInB1c2giLCJhbGlnbkluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js":
/*!**********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTable: () => (/* binding */ gfmTable)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-factory-space */ \"(ssr)/./node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-character */ \"(ssr)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol */ \"(ssr)/./node_modules/micromark-util-symbol/lib/constants.js\");\n/* harmony import */ var _edit_map_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./edit-map.js */ \"(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js\");\n/* harmony import */ var _infer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./infer.js */ \"(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js\");\n/**\n * @import {Event, Extension, Point, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */ /**\n * @typedef {[number, number, number, number]} Range\n *   Cell info.\n *\n * @typedef {0 | 1 | 2 | 3} RowKind\n *   Where we are: `1` for head row, `2` for delimiter row, `3` for body row.\n */ \n\n\n\n\n\n/**\n * Create an HTML extension for `micromark` to support GitHub tables syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   table syntax.\n */ function gfmTable() {\n    return {\n        flow: {\n            null: {\n                name: \"table\",\n                tokenize: tokenizeTable,\n                resolveAll: resolveTable\n            }\n        }\n    };\n}\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */ function tokenizeTable(effects, ok, nok) {\n    const self = this;\n    let size = 0;\n    let sizeB = 0;\n    /** @type {boolean | undefined} */ let seen;\n    return start;\n    /**\n   * Start of a GFM table.\n   *\n   * If there is a valid table row or table head before, then we try to parse\n   * another row.\n   * Otherwise, we try to parse a head.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   * @type {State}\n   */ function start(code) {\n        let index = self.events.length - 1;\n        while(index > -1){\n            const type = self.events[index][1].type;\n            if (type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.lineEnding || // Note: markdown-rs uses `whitespace` instead of `linePrefix`\n            type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.linePrefix) index--;\n            else break;\n        }\n        const tail = index > -1 ? self.events[index][1].type : null;\n        const next = tail === \"tableHead\" || tail === \"tableRow\" ? bodyRowStart : headRowBefore;\n        // Don’t allow lazy body rows.\n        if (next === bodyRowStart && self.parser.lazy[self.now().line]) {\n            return nok(code);\n        }\n        return next(code);\n    }\n    /**\n   * Before table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowBefore(code) {\n        effects.enter(\"tableHead\");\n        effects.enter(\"tableRow\");\n        return headRowStart(code);\n    }\n    /**\n   * Before table head row, after whitespace.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowStart(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n            return headRowBreak(code);\n        }\n        // To do: micromark-js should let us parse our own whitespace in extensions,\n        // like `markdown-rs`:\n        //\n        // ```js\n        // // 4+ spaces.\n        // if (markdownSpace(code)) {\n        //   return nok(code)\n        // }\n        // ```\n        seen = true;\n        // Count the first character, that isn’t a pipe, double.\n        sizeB += 1;\n        return headRowBreak(code);\n    }\n    /**\n   * At break in table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *       ^\n   *         ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowBreak(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof) {\n            // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n            return nok(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEnding)(code)) {\n            // If anything other than one pipe (ignoring whitespace) was used, it’s fine.\n            if (sizeB > 1) {\n                sizeB = 0;\n                // To do: check if this works.\n                // Feel free to interrupt:\n                self.interrupt = true;\n                effects.exit(\"tableRow\");\n                effects.enter(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.lineEnding);\n                effects.consume(code);\n                effects.exit(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.lineEnding);\n                return headDelimiterStart;\n            }\n            // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n            return nok(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownSpace)(code)) {\n            // To do: check if this is fine.\n            // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)\n            // State::Retry(space_or_tab(tokenizer))\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(effects, headRowBreak, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.whitespace)(code);\n        }\n        sizeB += 1;\n        if (seen) {\n            seen = false;\n            // Header cell count.\n            size += 1;\n        }\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n            effects.enter(\"tableCellDivider\");\n            effects.consume(code);\n            effects.exit(\"tableCellDivider\");\n            // Whether a delimiter was seen.\n            seen = true;\n            return headRowBreak;\n        }\n        // Anything else is cell data.\n        effects.enter(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data);\n        return headRowData(code);\n    }\n    /**\n   * In table head row data.\n   *\n   * ```markdown\n   * > | | a |\n   *       ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headRowData(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEndingOrSpace)(code)) {\n            effects.exit(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data);\n            return headRowBreak(code);\n        }\n        effects.consume(code);\n        return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.backslash ? headRowEscape : headRowData;\n    }\n    /**\n   * In table head row escape.\n   *\n   * ```markdown\n   * > | | a\\-b |\n   *         ^\n   *   | | ---- |\n   *   | | c    |\n   * ```\n   *\n   * @type {State}\n   */ function headRowEscape(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.backslash || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n            effects.consume(code);\n            return headRowData;\n        }\n        return headRowData(code);\n    }\n    /**\n   * Before delimiter row.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterStart(code) {\n        // Reset `interrupt`.\n        self.interrupt = false;\n        // Note: in `markdown-rs`, we need to handle piercing here too.\n        if (self.parser.lazy[self.now().line]) {\n            return nok(code);\n        }\n        effects.enter(\"tableDelimiterRow\");\n        // Track if we’ve seen a `:` or `|`.\n        seen = false;\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownSpace)(code)) {\n            (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(self.parser.constructs.disable.null, \"expected `disabled.null`\");\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(effects, headDelimiterBefore, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.linePrefix, self.parser.constructs.disable.null.includes(\"codeIndented\") ? undefined : micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.constants.tabSize)(code);\n        }\n        return headDelimiterBefore(code);\n    }\n    /**\n   * Before delimiter row, after optional whitespace.\n   *\n   * Reused when a `|` is found later, to parse another cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterBefore(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dash || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.colon) {\n            return headDelimiterValueBefore(code);\n        }\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n            seen = true;\n            // If we start with a pipe, we open a cell marker.\n            effects.enter(\"tableCellDivider\");\n            effects.consume(code);\n            effects.exit(\"tableCellDivider\");\n            return headDelimiterCellBefore;\n        }\n        // More whitespace / empty row not allowed at start.\n        return headDelimiterNok(code);\n    }\n    /**\n   * After `|`, before delimiter cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterCellBefore(code) {\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownSpace)(code)) {\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(effects, headDelimiterValueBefore, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.whitespace)(code);\n        }\n        return headDelimiterValueBefore(code);\n    }\n    /**\n   * Before delimiter cell value.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterValueBefore(code) {\n        // Align: left.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.colon) {\n            sizeB += 1;\n            seen = true;\n            effects.enter(\"tableDelimiterMarker\");\n            effects.consume(code);\n            effects.exit(\"tableDelimiterMarker\");\n            return headDelimiterLeftAlignmentAfter;\n        }\n        // Align: none.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dash) {\n            sizeB += 1;\n            // To do: seems weird that this *isn’t* left aligned, but that state is used?\n            return headDelimiterLeftAlignmentAfter(code);\n        }\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEnding)(code)) {\n            return headDelimiterCellAfter(code);\n        }\n        return headDelimiterNok(code);\n    }\n    /**\n   * After delimiter cell left alignment marker.\n   *\n   * ```markdown\n   *   | | a  |\n   * > | | :- |\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterLeftAlignmentAfter(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dash) {\n            effects.enter(\"tableDelimiterFiller\");\n            return headDelimiterFiller(code);\n        }\n        // Anything else is not ok after the left-align colon.\n        return headDelimiterNok(code);\n    }\n    /**\n   * In delimiter cell filler.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterFiller(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dash) {\n            effects.consume(code);\n            return headDelimiterFiller;\n        }\n        // Align is `center` if it was `left`, `right` otherwise.\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.colon) {\n            seen = true;\n            effects.exit(\"tableDelimiterFiller\");\n            effects.enter(\"tableDelimiterMarker\");\n            effects.consume(code);\n            effects.exit(\"tableDelimiterMarker\");\n            return headDelimiterRightAlignmentAfter;\n        }\n        effects.exit(\"tableDelimiterFiller\");\n        return headDelimiterRightAlignmentAfter(code);\n    }\n    /**\n   * After delimiter cell right alignment marker.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterRightAlignmentAfter(code) {\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownSpace)(code)) {\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(effects, headDelimiterCellAfter, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.whitespace)(code);\n        }\n        return headDelimiterCellAfter(code);\n    }\n    /**\n   * After delimiter cell.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterCellAfter(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n            return headDelimiterBefore(code);\n        }\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEnding)(code)) {\n            // Exit when:\n            // * there was no `:` or `|` at all (it’s a thematic break or setext\n            //   underline instead)\n            // * the header cell count is not the delimiter cell count\n            if (!seen || size !== sizeB) {\n                return headDelimiterNok(code);\n            }\n            // Note: in markdown-rs`, a reset is needed here.\n            effects.exit(\"tableDelimiterRow\");\n            effects.exit(\"tableHead\");\n            // To do: in `markdown-rs`, resolvers need to be registered manually.\n            // effects.register_resolver(ResolveName::GfmTable)\n            return ok(code);\n        }\n        return headDelimiterNok(code);\n    }\n    /**\n   * In delimiter row, at a disallowed byte.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | x |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function headDelimiterNok(code) {\n        // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n        return nok(code);\n    }\n    /**\n   * Before table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowStart(code) {\n        // Note: in `markdown-rs` we need to manually take care of a prefix,\n        // but in `micromark-js` that is done for us, so if we’re here, we’re\n        // never at whitespace.\n        effects.enter(\"tableRow\");\n        return bodyRowBreak(code);\n    }\n    /**\n   * At break in table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   *       ^\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowBreak(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n            effects.enter(\"tableCellDivider\");\n            effects.consume(code);\n            effects.exit(\"tableCellDivider\");\n            return bodyRowBreak;\n        }\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEnding)(code)) {\n            effects.exit(\"tableRow\");\n            return ok(code);\n        }\n        if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownSpace)(code)) {\n            return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(effects, bodyRowBreak, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.whitespace)(code);\n        }\n        // Anything else is cell content.\n        effects.enter(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data);\n        return bodyRowData(code);\n    }\n    /**\n   * In table body row data.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowData(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEndingOrSpace)(code)) {\n            effects.exit(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data);\n            return bodyRowBreak(code);\n        }\n        effects.consume(code);\n        return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.backslash ? bodyRowEscape : bodyRowData;\n    }\n    /**\n   * In table body row escape.\n   *\n   * ```markdown\n   *   | | a    |\n   *   | | ---- |\n   * > | | b\\-c |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */ function bodyRowEscape(code) {\n        if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.backslash || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n            effects.consume(code);\n            return bodyRowData;\n        }\n        return bodyRowData(code);\n    }\n}\n/** @type {Resolver} */ function resolveTable(events, context) {\n    let index = -1;\n    let inFirstCellAwaitingPipe = true;\n    /** @type {RowKind} */ let rowKind = 0;\n    /** @type {Range} */ let lastCell = [\n        0,\n        0,\n        0,\n        0\n    ];\n    /** @type {Range} */ let cell = [\n        0,\n        0,\n        0,\n        0\n    ];\n    let afterHeadAwaitingFirstBodyRow = false;\n    let lastTableEnd = 0;\n    /** @type {Token | undefined} */ let currentTable;\n    /** @type {Token | undefined} */ let currentBody;\n    /** @type {Token | undefined} */ let currentCell;\n    const map = new _edit_map_js__WEBPACK_IMPORTED_MODULE_6__.EditMap();\n    while(++index < events.length){\n        const event = events[index];\n        const token = event[1];\n        if (event[0] === \"enter\") {\n            // Start of head.\n            if (token.type === \"tableHead\") {\n                afterHeadAwaitingFirstBodyRow = false;\n                // Inject previous (body end and) table end.\n                if (lastTableEnd !== 0) {\n                    (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(currentTable, \"there should be a table opening\");\n                    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);\n                    currentBody = undefined;\n                    lastTableEnd = 0;\n                }\n                // Inject table start.\n                currentTable = {\n                    type: \"table\",\n                    start: Object.assign({}, token.start),\n                    // Note: correct end is set later.\n                    end: Object.assign({}, token.end)\n                };\n                map.add(index, 0, [\n                    [\n                        \"enter\",\n                        currentTable,\n                        context\n                    ]\n                ]);\n            } else if (token.type === \"tableRow\" || token.type === \"tableDelimiterRow\") {\n                inFirstCellAwaitingPipe = true;\n                currentCell = undefined;\n                lastCell = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                cell = [\n                    0,\n                    index + 1,\n                    0,\n                    0\n                ];\n                // Inject table body start.\n                if (afterHeadAwaitingFirstBodyRow) {\n                    afterHeadAwaitingFirstBodyRow = false;\n                    currentBody = {\n                        type: \"tableBody\",\n                        start: Object.assign({}, token.start),\n                        // Note: correct end is set later.\n                        end: Object.assign({}, token.end)\n                    };\n                    map.add(index, 0, [\n                        [\n                            \"enter\",\n                            currentBody,\n                            context\n                        ]\n                    ]);\n                }\n                rowKind = token.type === \"tableDelimiterRow\" ? 2 : currentBody ? 3 : 1;\n            } else if (rowKind && (token.type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data || token.type === \"tableDelimiterMarker\" || token.type === \"tableDelimiterFiller\")) {\n                inFirstCellAwaitingPipe = false;\n                // First value in cell.\n                if (cell[2] === 0) {\n                    if (lastCell[1] !== 0) {\n                        cell[0] = cell[1];\n                        currentCell = flushCell(map, context, lastCell, rowKind, undefined, currentCell);\n                        lastCell = [\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                    }\n                    cell[2] = index;\n                }\n            } else if (token.type === \"tableCellDivider\") {\n                if (inFirstCellAwaitingPipe) {\n                    inFirstCellAwaitingPipe = false;\n                } else {\n                    if (lastCell[1] !== 0) {\n                        cell[0] = cell[1];\n                        currentCell = flushCell(map, context, lastCell, rowKind, undefined, currentCell);\n                    }\n                    lastCell = cell;\n                    cell = [\n                        lastCell[1],\n                        index,\n                        0,\n                        0\n                    ];\n                }\n            }\n        } else if (token.type === \"tableHead\") {\n            afterHeadAwaitingFirstBodyRow = true;\n            lastTableEnd = index;\n        } else if (token.type === \"tableRow\" || token.type === \"tableDelimiterRow\") {\n            lastTableEnd = index;\n            if (lastCell[1] !== 0) {\n                cell[0] = cell[1];\n                currentCell = flushCell(map, context, lastCell, rowKind, index, currentCell);\n            } else if (cell[1] !== 0) {\n                currentCell = flushCell(map, context, cell, rowKind, index, currentCell);\n            }\n            rowKind = 0;\n        } else if (rowKind && (token.type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data || token.type === \"tableDelimiterMarker\" || token.type === \"tableDelimiterFiller\")) {\n            cell[3] = index;\n        }\n    }\n    if (lastTableEnd !== 0) {\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(currentTable, \"expected table opening\");\n        flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);\n    }\n    map.consume(context.events);\n    // To do: move this into `html`, when events are exposed there.\n    // That’s what `markdown-rs` does.\n    // That needs updates to `mdast-util-gfm-table`.\n    index = -1;\n    while(++index < context.events.length){\n        const event = context.events[index];\n        if (event[0] === \"enter\" && event[1].type === \"table\") {\n            event[1]._align = (0,_infer_js__WEBPACK_IMPORTED_MODULE_7__.gfmTableAlign)(context.events, index);\n        }\n    }\n    return events;\n}\n/**\n * Generate a cell.\n *\n * @param {EditMap} map\n * @param {Readonly<TokenizeContext>} context\n * @param {Readonly<Range>} range\n * @param {RowKind} rowKind\n * @param {number | undefined} rowEnd\n * @param {Token | undefined} previousCell\n * @returns {Token | undefined}\n */ // eslint-disable-next-line max-params\nfunction flushCell(map, context, range, rowKind, rowEnd, previousCell) {\n    // `markdown-rs` uses:\n    // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'\n    const groupName = rowKind === 1 ? \"tableHeader\" : rowKind === 2 ? \"tableDelimiter\" : \"tableData\";\n    // `markdown-rs` uses:\n    // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'\n    const valueName = \"tableContent\";\n    // Insert an exit for the previous cell, if there is one.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //          ^-- exit\n    //           ^^^^-- this cell\n    // ```\n    if (range[0] !== 0) {\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(previousCell, \"expected previous cell enter\");\n        previousCell.end = Object.assign({}, getPoint(context.events, range[0]));\n        map.add(range[0], 0, [\n            [\n                \"exit\",\n                previousCell,\n                context\n            ]\n        ]);\n    }\n    // Insert enter of this cell.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //           ^-- enter\n    //           ^^^^-- this cell\n    // ```\n    const now = getPoint(context.events, range[1]);\n    previousCell = {\n        type: groupName,\n        start: Object.assign({}, now),\n        // Note: correct end is set later.\n        end: Object.assign({}, now)\n    };\n    map.add(range[1], 0, [\n        [\n            \"enter\",\n            previousCell,\n            context\n        ]\n    ]);\n    // Insert text start at first data start and end at last data end, and\n    // remove events between.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //            ^-- enter\n    //             ^-- exit\n    //           ^^^^-- this cell\n    // ```\n    if (range[2] !== 0) {\n        const relatedStart = getPoint(context.events, range[2]);\n        const relatedEnd = getPoint(context.events, range[3]);\n        /** @type {Token} */ const valueToken = {\n            type: valueName,\n            start: Object.assign({}, relatedStart),\n            end: Object.assign({}, relatedEnd)\n        };\n        map.add(range[2], 0, [\n            [\n                \"enter\",\n                valueToken,\n                context\n            ]\n        ]);\n        (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(range[3] !== 0);\n        if (rowKind !== 2) {\n            // Fix positional info on remaining events\n            const start = context.events[range[2]];\n            const end = context.events[range[3]];\n            start[1].end = Object.assign({}, end[1].end);\n            start[1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.chunkText;\n            start[1].contentType = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.constants.contentTypeText;\n            // Remove if needed.\n            if (range[3] > range[2] + 1) {\n                const a = range[2] + 1;\n                const b = range[3] - range[2] - 1;\n                map.add(a, b, []);\n            }\n        }\n        map.add(range[3] + 1, 0, [\n            [\n                \"exit\",\n                valueToken,\n                context\n            ]\n        ]);\n    }\n    // Insert an exit for the last cell, if at the row end.\n    //\n    // ```markdown\n    // > | | aa | bb | cc |\n    //                    ^-- exit\n    //               ^^^^^^-- this cell (the last one contains two “between” parts)\n    // ```\n    if (rowEnd !== undefined) {\n        previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));\n        map.add(rowEnd, 0, [\n            [\n                \"exit\",\n                previousCell,\n                context\n            ]\n        ]);\n        previousCell = undefined;\n    }\n    return previousCell;\n}\n/**\n * Generate table end (and table body end).\n *\n * @param {Readonly<EditMap>} map\n * @param {Readonly<TokenizeContext>} context\n * @param {number} index\n * @param {Token} table\n * @param {Token | undefined} tableBody\n */ // eslint-disable-next-line max-params\nfunction flushTableEnd(map, context, index, table, tableBody) {\n    /** @type {Array<Event>} */ const exits = [];\n    const related = getPoint(context.events, index);\n    if (tableBody) {\n        tableBody.end = Object.assign({}, related);\n        exits.push([\n            \"exit\",\n            tableBody,\n            context\n        ]);\n    }\n    table.end = Object.assign({}, related);\n    exits.push([\n        \"exit\",\n        table,\n        context\n    ]);\n    map.add(index + 1, 0, exits);\n}\n/**\n * @param {Readonly<Array<Event>>} events\n * @param {number} index\n * @returns {Readonly<Point>}\n */ function getPoint(events, index) {\n    const event = events[index];\n    const side = event[0] === \"enter\" ? \"start\" : \"end\";\n    return event[1][side];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9zeW50YXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FFRDs7Ozs7O0NBTUMsR0FFa0M7QUFDaUI7QUFLbkI7QUFDNEI7QUFDeEI7QUFDRztBQUV4Qzs7Ozs7O0NBTUMsR0FDTSxTQUFTVztJQUNkLE9BQU87UUFDTEMsTUFBTTtZQUNKQyxNQUFNO2dCQUFDQyxNQUFNO2dCQUFTQyxVQUFVQztnQkFBZUMsWUFBWUM7WUFBWTtRQUN6RTtJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxTQUFTRixjQUFjRyxPQUFPLEVBQUVuQixFQUFFLEVBQUVvQixHQUFHO0lBQ3JDLE1BQU1DLE9BQU8sSUFBSTtJQUNqQixJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsUUFBUTtJQUNaLGdDQUFnQyxHQUNoQyxJQUFJQztJQUVKLE9BQU9DO0lBRVA7Ozs7Ozs7Ozs7Ozs7OztHQWVDLEdBQ0QsU0FBU0EsTUFBTUMsSUFBSTtRQUNqQixJQUFJQyxRQUFRTixLQUFLTyxNQUFNLENBQUNDLE1BQU0sR0FBRztRQUVqQyxNQUFPRixRQUFRLENBQUMsRUFBRztZQUNqQixNQUFNRyxPQUFPVCxLQUFLTyxNQUFNLENBQUNELE1BQU0sQ0FBQyxFQUFFLENBQUNHLElBQUk7WUFDdkMsSUFDRUEsU0FBU3RCLHdEQUFLQSxDQUFDdUIsVUFBVSxJQUN6Qiw4REFBOEQ7WUFDOURELFNBQVN0Qix3REFBS0EsQ0FBQ3dCLFVBQVUsRUFFekJMO2lCQUNHO1FBQ1A7UUFFQSxNQUFNTSxPQUFPTixRQUFRLENBQUMsSUFBSU4sS0FBS08sTUFBTSxDQUFDRCxNQUFNLENBQUMsRUFBRSxDQUFDRyxJQUFJLEdBQUc7UUFFdkQsTUFBTUksT0FDSkQsU0FBUyxlQUFlQSxTQUFTLGFBQWFFLGVBQWVDO1FBRS9ELDhCQUE4QjtRQUM5QixJQUFJRixTQUFTQyxnQkFBZ0JkLEtBQUtnQixNQUFN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QUdGLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdzQjtJQUM5QkQsTUFBTUUsSUFBSSxDQUFDO1FBQUM7UUFBUUo7UUFBT2xDO0tBQVE7SUFFbkNVLElBQUlPLEdBQUcsQ0FBQy9ELFFBQVEsR0FBRyxHQUFHa0Y7QUFDeEI7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU1gsU0FBU3RFLE1BQU0sRUFBRUQsS0FBSztJQUM3QixNQUFNeUQsUUFBUXhELE1BQU0sQ0FBQ0QsTUFBTTtJQUMzQixNQUFNcUYsT0FBTzVCLEtBQUssQ0FBQyxFQUFFLEtBQUssVUFBVSxVQUFVO0lBQzlDLE9BQU9BLEtBQUssQ0FBQyxFQUFFLENBQUM0QixLQUFLO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2llbC1zdHVkaW8vLi9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9zeW50YXguanM/ZjQxMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0V2ZW50LCBFeHRlbnNpb24sIFBvaW50LCBSZXNvbHZlciwgU3RhdGUsIFRva2VuLCBUb2tlbml6ZUNvbnRleHQsIFRva2VuaXplcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtdHlwZXMnXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7W251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl19IFJhbmdlXG4gKiAgIENlbGwgaW5mby5cbiAqXG4gKiBAdHlwZWRlZiB7MCB8IDEgfCAyIHwgM30gUm93S2luZFxuICogICBXaGVyZSB3ZSBhcmU6IGAxYCBmb3IgaGVhZCByb3csIGAyYCBmb3IgZGVsaW1pdGVyIHJvdywgYDNgIGZvciBib2R5IHJvdy5cbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHtcbiAgbWFya2Rvd25MaW5lRW5kaW5nLFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICBtYXJrZG93blNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmltcG9ydCB7Y29kZXMsIGNvbnN0YW50cywgdHlwZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbCdcbmltcG9ydCB7RWRpdE1hcH0gZnJvbSAnLi9lZGl0LW1hcC5qcydcbmltcG9ydCB7Z2ZtVGFibGVBbGlnbn0gZnJvbSAnLi9pbmZlci5qcydcblxuLyoqXG4gKiBDcmVhdGUgYW4gSFRNTCBleHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRvIHN1cHBvcnQgR2l0SHViIHRhYmxlcyBzeW50YXguXG4gKlxuICogQHJldHVybnMge0V4dGVuc2lvbn1cbiAqICAgRXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0aGF0IGNhbiBiZSBwYXNzZWQgaW4gYGV4dGVuc2lvbnNgIHRvIGVuYWJsZSBHRk1cbiAqICAgdGFibGUgc3ludGF4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtVGFibGUoKSB7XG4gIHJldHVybiB7XG4gICAgZmxvdzoge1xuICAgICAgbnVsbDoge25hbWU6ICd0YWJsZScsIHRva2VuaXplOiB0b2tlbml6ZVRhYmxlLCByZXNvbHZlQWxsOiByZXNvbHZlVGFibGV9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplVGFibGUoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgc2l6ZSA9IDBcbiAgbGV0IHNpemVCID0gMFxuICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBzZWVuXG5cbiAgcmV0dXJuIHN0YXJ0XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG9mIGEgR0ZNIHRhYmxlLlxuICAgKlxuICAgKiBJZiB0aGVyZSBpcyBhIHZhbGlkIHRhYmxlIHJvdyBvciB0YWJsZSBoZWFkIGJlZm9yZSwgdGhlbiB3ZSB0cnkgdG8gcGFyc2VcbiAgICogYW5vdGhlciByb3cuXG4gICAqIE90aGVyd2lzZSwgd2UgdHJ5IHRvIHBhcnNlIGEgaGVhZC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHwgYSB8XG4gICAqICAgICBeXG4gICAqICAgfCB8IC0gfFxuICAgKiA+IHwgfCBiIHxcbiAgICogICAgIF5cbiAgICogYGBgXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBsZXQgaW5kZXggPSBzZWxmLmV2ZW50cy5sZW5ndGggLSAxXG5cbiAgICB3aGlsZSAoaW5kZXggPiAtMSkge1xuICAgICAgY29uc3QgdHlwZSA9IHNlbGYuZXZlbnRzW2luZGV4XVsxXS50eXBlXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmcgfHxcbiAgICAgICAgLy8gTm90ZTogbWFya2Rvd24tcnMgdXNlcyBgd2hpdGVzcGFjZWAgaW5zdGVhZCBvZiBgbGluZVByZWZpeGBcbiAgICAgICAgdHlwZSA9PT0gdHlwZXMubGluZVByZWZpeFxuICAgICAgKVxuICAgICAgICBpbmRleC0tXG4gICAgICBlbHNlIGJyZWFrXG4gICAgfVxuXG4gICAgY29uc3QgdGFpbCA9IGluZGV4ID4gLTEgPyBzZWxmLmV2ZW50c1tpbmRleF1bMV0udHlwZSA6IG51bGxcblxuICAgIGNvbnN0IG5leHQgPVxuICAgICAgdGFpbCA9PT0gJ3RhYmxlSGVhZCcgfHwgdGFpbCA9PT0gJ3RhYmxlUm93JyA/IGJvZHlSb3dTdGFydCA6IGhlYWRSb3dCZWZvcmVcblxuICAgIC8vIERvbuKAmXQgYWxsb3cgbGF6eSBib2R5IHJvd3MuXG4gICAgaWYgKG5leHQgPT09IGJvZHlSb3dTdGFydCAmJiBzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0pIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dChjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSB0YWJsZSBoZWFkIHJvdy5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHwgYSB8XG4gICAqICAgICBeXG4gICAqICAgfCB8IC0gfFxuICAgKiAgIHwgfCBiIHxcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWRSb3dCZWZvcmUoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlSGVhZCcpXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVSb3cnKVxuICAgIHJldHVybiBoZWFkUm93U3RhcnQoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgdGFibGUgaGVhZCByb3csIGFmdGVyIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB8IGEgfFxuICAgKiAgICAgXlxuICAgKiAgIHwgfCAtIHxcbiAgICogICB8IHwgYiB8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkUm93U3RhcnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgcmV0dXJuIGhlYWRSb3dCcmVhayhjb2RlKVxuICAgIH1cblxuICAgIC8vIFRvIGRvOiBtaWNyb21hcmstanMgc2hvdWxkIGxldCB1cyBwYXJzZSBvdXIgb3duIHdoaXRlc3BhY2UgaW4gZXh0ZW5zaW9ucyxcbiAgICAvLyBsaWtlIGBtYXJrZG93bi1yc2A6XG4gICAgLy9cbiAgICAvLyBgYGBqc1xuICAgIC8vIC8vIDQrIHNwYWNlcy5cbiAgICAvLyBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgIC8vICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIC8vIH1cbiAgICAvLyBgYGBcblxuICAgIHNlZW4gPSB0cnVlXG4gICAgLy8gQ291bnQgdGhlIGZpcnN0IGNoYXJhY3RlciwgdGhhdCBpc27igJl0IGEgcGlwZSwgZG91YmxlLlxuICAgIHNpemVCICs9IDFcbiAgICByZXR1cm4gaGVhZFJvd0JyZWFrKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQXQgYnJlYWsgaW4gdGFibGUgaGVhZCByb3cuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB8IGEgfFxuICAgKiAgICAgXlxuICAgKiAgICAgICBeXG4gICAqICAgICAgICAgXlxuICAgKiAgIHwgfCAtIHxcbiAgICogICB8IHwgYiB8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkUm93QnJlYWsoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy5lb2YpIHtcbiAgICAgIC8vIE5vdGU6IGluIGBtYXJrZG93bi1yc2AsIHdlIG5lZWQgdG8gcmVzZXQsIGluIGBtaWNyb21hcmstanNgIHdlIGRvbuKAmHQuXG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgLy8gSWYgYW55dGhpbmcgb3RoZXIgdGhhbiBvbmUgcGlwZSAoaWdub3Jpbmcgd2hpdGVzcGFjZSkgd2FzIHVzZWQsIGl04oCZcyBmaW5lLlxuICAgICAgaWYgKHNpemVCID4gMSkge1xuICAgICAgICBzaXplQiA9IDBcbiAgICAgICAgLy8gVG8gZG86IGNoZWNrIGlmIHRoaXMgd29ya3MuXG4gICAgICAgIC8vIEZlZWwgZnJlZSB0byBpbnRlcnJ1cHQ6XG4gICAgICAgIHNlbGYuaW50ZXJydXB0ID0gdHJ1ZVxuICAgICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlUm93JylcbiAgICAgICAgZWZmZWN0cy5lbnRlcih0eXBlcy5saW5lRW5kaW5nKVxuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLmxpbmVFbmRpbmcpXG4gICAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyU3RhcnRcbiAgICAgIH1cblxuICAgICAgLy8gTm90ZTogaW4gYG1hcmtkb3duLXJzYCwgd2UgbmVlZCB0byByZXNldCwgaW4gYG1pY3JvbWFyay1qc2Agd2UgZG9u4oCYdC5cbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgLy8gVG8gZG86IGNoZWNrIGlmIHRoaXMgaXMgZmluZS5cbiAgICAgIC8vIGVmZmVjdHMuYXR0ZW1wdChTdGF0ZTo6TmV4dChTdGF0ZU5hbWU6OkdmbVRhYmxlSGVhZFJvd0JyZWFrKSwgU3RhdGU6Ok5vaylcbiAgICAgIC8vIFN0YXRlOjpSZXRyeShzcGFjZV9vcl90YWIodG9rZW5pemVyKSlcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgaGVhZFJvd0JyZWFrLCB0eXBlcy53aGl0ZXNwYWNlKShjb2RlKVxuICAgIH1cblxuICAgIHNpemVCICs9IDFcblxuICAgIGlmIChzZWVuKSB7XG4gICAgICBzZWVuID0gZmFsc2VcbiAgICAgIC8vIEhlYWRlciBjZWxsIGNvdW50LlxuICAgICAgc2l6ZSArPSAxXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIC8vIFdoZXRoZXIgYSBkZWxpbWl0ZXIgd2FzIHNlZW4uXG4gICAgICBzZWVuID0gdHJ1ZVxuICAgICAgcmV0dXJuIGhlYWRSb3dCcmVha1xuICAgIH1cblxuICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgY2VsbCBkYXRhLlxuICAgIGVmZmVjdHMuZW50ZXIodHlwZXMuZGF0YSlcbiAgICByZXR1cm4gaGVhZFJvd0RhdGEoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiB0YWJsZSBoZWFkIHJvdyBkYXRhLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgfCBhIHxcbiAgICogICAgICAgXlxuICAgKiAgIHwgfCAtIHxcbiAgICogICB8IHwgYiB8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkUm93RGF0YShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhciB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLmRhdGEpXG4gICAgICByZXR1cm4gaGVhZFJvd0JyZWFrKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCA/IGhlYWRSb3dFc2NhcGUgOiBoZWFkUm93RGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHRhYmxlIGhlYWQgcm93IGVzY2FwZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHwgYVxcLWIgfFxuICAgKiAgICAgICAgIF5cbiAgICogICB8IHwgLS0tLSB8XG4gICAqICAgfCB8IGMgICAgfFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZFJvd0VzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCB8fCBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaGVhZFJvd0RhdGFcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZFJvd0RhdGEoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgZGVsaW1pdGVyIHJvdy5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqID4gfCB8IC0gfFxuICAgKiAgICAgXlxuICAgKiAgIHwgfCBiIHxcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWREZWxpbWl0ZXJTdGFydChjb2RlKSB7XG4gICAgLy8gUmVzZXQgYGludGVycnVwdGAuXG4gICAgc2VsZi5pbnRlcnJ1cHQgPSBmYWxzZVxuXG4gICAgLy8gTm90ZTogaW4gYG1hcmtkb3duLXJzYCwgd2UgbmVlZCB0byBoYW5kbGUgcGllcmNpbmcgaGVyZSB0b28uXG4gICAgaWYgKHNlbGYucGFyc2VyLmxhenlbc2VsZi5ub3coKS5saW5lXSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyUm93JylcbiAgICAvLyBUcmFjayBpZiB3ZeKAmXZlIHNlZW4gYSBgOmAgb3IgYHxgLlxuICAgIHNlZW4gPSBmYWxzZVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGFzc2VydChzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbCwgJ2V4cGVjdGVkIGBkaXNhYmxlZC5udWxsYCcpXG4gICAgICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBoZWFkRGVsaW1pdGVyQmVmb3JlLFxuICAgICAgICB0eXBlcy5saW5lUHJlZml4LFxuICAgICAgICBzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcygnY29kZUluZGVudGVkJylcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogY29uc3RhbnRzLnRhYlNpemVcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZERlbGltaXRlckJlZm9yZShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSBkZWxpbWl0ZXIgcm93LCBhZnRlciBvcHRpb25hbCB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBSZXVzZWQgd2hlbiBhIGB8YCBpcyBmb3VuZCBsYXRlciwgdG8gcGFyc2UgYW5vdGhlciBjZWxsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogPiB8IHwgLSB8XG4gICAqICAgICBeXG4gICAqICAgfCB8IGIgfFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckJlZm9yZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2ggfHwgY29kZSA9PT0gY29kZXMuY29sb24pIHtcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyVmFsdWVCZWZvcmUoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMudmVydGljYWxCYXIpIHtcbiAgICAgIHNlZW4gPSB0cnVlXG4gICAgICAvLyBJZiB3ZSBzdGFydCB3aXRoIGEgcGlwZSwgd2Ugb3BlbiBhIGNlbGwgbWFya2VyLlxuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICByZXR1cm4gaGVhZERlbGltaXRlckNlbGxCZWZvcmVcbiAgICB9XG5cbiAgICAvLyBNb3JlIHdoaXRlc3BhY2UgLyBlbXB0eSByb3cgbm90IGFsbG93ZWQgYXQgc3RhcnQuXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJOb2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBgfGAsIGJlZm9yZSBkZWxpbWl0ZXIgY2VsbC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqID4gfCB8IC0gfFxuICAgKiAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWREZWxpbWl0ZXJDZWxsQmVmb3JlKGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgaGVhZERlbGltaXRlclZhbHVlQmVmb3JlLFxuICAgICAgICB0eXBlcy53aGl0ZXNwYWNlXG4gICAgICApKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJWYWx1ZUJlZm9yZShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSBkZWxpbWl0ZXIgY2VsbCB2YWx1ZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqID4gfCB8IC0gfFxuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkRGVsaW1pdGVyVmFsdWVCZWZvcmUoY29kZSkge1xuICAgIC8vIEFsaWduOiBsZWZ0LlxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5jb2xvbikge1xuICAgICAgc2l6ZUIgKz0gMVxuICAgICAgc2VlbiA9IHRydWVcblxuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyTWFya2VyJylcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTGVmdEFsaWdubWVudEFmdGVyXG4gICAgfVxuXG4gICAgLy8gQWxpZ246IG5vbmUuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2gpIHtcbiAgICAgIHNpemVCICs9IDFcbiAgICAgIC8vIFRvIGRvOiBzZWVtcyB3ZWlyZCB0aGF0IHRoaXMgKmlzbuKAmXQqIGxlZnQgYWxpZ25lZCwgYnV0IHRoYXQgc3RhdGUgaXMgdXNlZD9cbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTGVmdEFsaWdubWVudEFmdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyQ2VsbEFmdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJOb2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkZWxpbWl0ZXIgY2VsbCBsZWZ0IGFsaWdubWVudCBtYXJrZXIuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgIHxcbiAgICogPiB8IHwgOi0gfFxuICAgKiAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckxlZnRBbGlnbm1lbnRBZnRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2gpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyRmlsbGVyKGNvZGUpXG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZSBpcyBub3Qgb2sgYWZ0ZXIgdGhlIGxlZnQtYWxpZ24gY29sb24uXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJOb2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBkZWxpbWl0ZXIgY2VsbCBmaWxsZXIuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiA+IHwgfCAtIHxcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckZpbGxlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2gpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJGaWxsZXJcbiAgICB9XG5cbiAgICAvLyBBbGlnbiBpcyBgY2VudGVyYCBpZiBpdCB3YXMgYGxlZnRgLCBgcmlnaHRgIG90aGVyd2lzZS5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuY29sb24pIHtcbiAgICAgIHNlZW4gPSB0cnVlXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZURlbGltaXRlck1hcmtlcicpXG4gICAgICByZXR1cm4gaGVhZERlbGltaXRlclJpZ2h0QWxpZ25tZW50QWZ0ZXJcbiAgICB9XG5cbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICByZXR1cm4gaGVhZERlbGltaXRlclJpZ2h0QWxpZ25tZW50QWZ0ZXIoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkZWxpbWl0ZXIgY2VsbCByaWdodCBhbGlnbm1lbnQgbWFya2VyLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCAgYSB8XG4gICAqID4gfCB8IC06IHxcbiAgICogICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkRGVsaW1pdGVyUmlnaHRBbGlnbm1lbnRBZnRlcihjb2RlKSB7XG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGhlYWREZWxpbWl0ZXJDZWxsQWZ0ZXIsXG4gICAgICAgIHR5cGVzLndoaXRlc3BhY2VcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZERlbGltaXRlckNlbGxBZnRlcihjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGRlbGltaXRlciBjZWxsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCAgYSB8XG4gICAqID4gfCB8IC06IHxcbiAgICogICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckNlbGxBZnRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyKSB7XG4gICAgICByZXR1cm4gaGVhZERlbGltaXRlckJlZm9yZShjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5lb2YgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICAvLyBFeGl0IHdoZW46XG4gICAgICAvLyAqIHRoZXJlIHdhcyBubyBgOmAgb3IgYHxgIGF0IGFsbCAoaXTigJlzIGEgdGhlbWF0aWMgYnJlYWsgb3Igc2V0ZXh0XG4gICAgICAvLyAgIHVuZGVybGluZSBpbnN0ZWFkKVxuICAgICAgLy8gKiB0aGUgaGVhZGVyIGNlbGwgY291bnQgaXMgbm90IHRoZSBkZWxpbWl0ZXIgY2VsbCBjb3VudFxuICAgICAgaWYgKCFzZWVuIHx8IHNpemUgIT09IHNpemVCKSB7XG4gICAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTm9rKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIC8vIE5vdGU6IGluIG1hcmtkb3duLXJzYCwgYSByZXNldCBpcyBuZWVkZWQgaGVyZS5cbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVEZWxpbWl0ZXJSb3cnKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZUhlYWQnKVxuICAgICAgLy8gVG8gZG86IGluIGBtYXJrZG93bi1yc2AsIHJlc29sdmVycyBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgbWFudWFsbHkuXG4gICAgICAvLyBlZmZlY3RzLnJlZ2lzdGVyX3Jlc29sdmVyKFJlc29sdmVOYW1lOjpHZm1UYWJsZSlcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gZGVsaW1pdGVyIHJvdywgYXQgYSBkaXNhbGxvd2VkIGJ5dGUuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiA+IHwgfCB4IHxcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlck5vayhjb2RlKSB7XG4gICAgLy8gTm90ZTogaW4gYG1hcmtkb3duLXJzYCwgd2UgbmVlZCB0byByZXNldCwgaW4gYG1pY3JvbWFyay1qc2Agd2UgZG9u4oCYdC5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQmVmb3JlIHRhYmxlIGJvZHkgcm93LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogICB8IHwgLSB8XG4gICAqID4gfCB8IGIgfFxuICAgKiAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYm9keVJvd1N0YXJ0KGNvZGUpIHtcbiAgICAvLyBOb3RlOiBpbiBgbWFya2Rvd24tcnNgIHdlIG5lZWQgdG8gbWFudWFsbHkgdGFrZSBjYXJlIG9mIGEgcHJlZml4LFxuICAgIC8vIGJ1dCBpbiBgbWljcm9tYXJrLWpzYCB0aGF0IGlzIGRvbmUgZm9yIHVzLCBzbyBpZiB3ZeKAmXJlIGhlcmUsIHdl4oCZcmVcbiAgICAvLyBuZXZlciBhdCB3aGl0ZXNwYWNlLlxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlUm93JylcbiAgICByZXR1cm4gYm9keVJvd0JyZWFrKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQXQgYnJlYWsgaW4gdGFibGUgYm9keSByb3cuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiAgIHwgfCAtIHxcbiAgICogPiB8IHwgYiB8XG4gICAqICAgICBeXG4gICAqICAgICAgIF5cbiAgICogICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBib2R5Um93QnJlYWsoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICByZXR1cm4gYm9keVJvd0JyZWFrXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVSb3cnKVxuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYm9keVJvd0JyZWFrLCB0eXBlcy53aGl0ZXNwYWNlKShjb2RlKVxuICAgIH1cblxuICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgY2VsbCBjb250ZW50LlxuICAgIGVmZmVjdHMuZW50ZXIodHlwZXMuZGF0YSlcbiAgICByZXR1cm4gYm9keVJvd0RhdGEoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiB0YWJsZSBib2R5IHJvdyBkYXRhLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogICB8IHwgLSB8XG4gICAqID4gfCB8IGIgfFxuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBib2R5Um93RGF0YShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhciB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLmRhdGEpXG4gICAgICByZXR1cm4gYm9keVJvd0JyZWFrKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCA/IGJvZHlSb3dFc2NhcGUgOiBib2R5Um93RGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHRhYmxlIGJvZHkgcm93IGVzY2FwZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSAgICB8XG4gICAqICAgfCB8IC0tLS0gfFxuICAgKiA+IHwgfCBiXFwtYyB8XG4gICAqICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYm9keVJvd0VzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCB8fCBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gYm9keVJvd0RhdGFcbiAgICB9XG5cbiAgICByZXR1cm4gYm9keVJvd0RhdGEoY29kZSlcbiAgfVxufVxuXG4vKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVGFibGUoZXZlbnRzLCBjb250ZXh0KSB7XG4gIGxldCBpbmRleCA9IC0xXG4gIGxldCBpbkZpcnN0Q2VsbEF3YWl0aW5nUGlwZSA9IHRydWVcbiAgLyoqIEB0eXBlIHtSb3dLaW5kfSAqL1xuICBsZXQgcm93S2luZCA9IDBcbiAgLyoqIEB0eXBlIHtSYW5nZX0gKi9cbiAgbGV0IGxhc3RDZWxsID0gWzAsIDAsIDAsIDBdXG4gIC8qKiBAdHlwZSB7UmFuZ2V9ICovXG4gIGxldCBjZWxsID0gWzAsIDAsIDAsIDBdXG4gIGxldCBhZnRlckhlYWRBd2FpdGluZ0ZpcnN0Qm9keVJvdyA9IGZhbHNlXG4gIGxldCBsYXN0VGFibGVFbmQgPSAwXG4gIC8qKiBAdHlwZSB7VG9rZW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBjdXJyZW50VGFibGVcbiAgLyoqIEB0eXBlIHtUb2tlbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGN1cnJlbnRCb2R5XG4gIC8qKiBAdHlwZSB7VG9rZW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBjdXJyZW50Q2VsbFxuXG4gIGNvbnN0IG1hcCA9IG5ldyBFZGl0TWFwKClcblxuICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpbmRleF1cbiAgICBjb25zdCB0b2tlbiA9IGV2ZW50WzFdXG5cbiAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgIC8vIFN0YXJ0IG9mIGhlYWQuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RhYmxlSGVhZCcpIHtcbiAgICAgICAgYWZ0ZXJIZWFkQXdhaXRpbmdGaXJzdEJvZHlSb3cgPSBmYWxzZVxuXG4gICAgICAgIC8vIEluamVjdCBwcmV2aW91cyAoYm9keSBlbmQgYW5kKSB0YWJsZSBlbmQuXG4gICAgICAgIGlmIChsYXN0VGFibGVFbmQgIT09IDApIHtcbiAgICAgICAgICBhc3NlcnQoY3VycmVudFRhYmxlLCAndGhlcmUgc2hvdWxkIGJlIGEgdGFibGUgb3BlbmluZycpXG4gICAgICAgICAgZmx1c2hUYWJsZUVuZChtYXAsIGNvbnRleHQsIGxhc3RUYWJsZUVuZCwgY3VycmVudFRhYmxlLCBjdXJyZW50Qm9keSlcbiAgICAgICAgICBjdXJyZW50Qm9keSA9IHVuZGVmaW5lZFxuICAgICAgICAgIGxhc3RUYWJsZUVuZCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluamVjdCB0YWJsZSBzdGFydC5cbiAgICAgICAgY3VycmVudFRhYmxlID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIHRva2VuLnN0YXJ0KSxcbiAgICAgICAgICAvLyBOb3RlOiBjb3JyZWN0IGVuZCBpcyBzZXQgbGF0ZXIuXG4gICAgICAgICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCB0b2tlbi5lbmQpXG4gICAgICAgIH1cbiAgICAgICAgbWFwLmFkZChpbmRleCwgMCwgW1snZW50ZXInLCBjdXJyZW50VGFibGUsIGNvbnRleHRdXSlcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZVJvdycgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyUm93J1xuICAgICAgKSB7XG4gICAgICAgIGluRmlyc3RDZWxsQXdhaXRpbmdQaXBlID0gdHJ1ZVxuICAgICAgICBjdXJyZW50Q2VsbCA9IHVuZGVmaW5lZFxuICAgICAgICBsYXN0Q2VsbCA9IFswLCAwLCAwLCAwXVxuICAgICAgICBjZWxsID0gWzAsIGluZGV4ICsgMSwgMCwgMF1cblxuICAgICAgICAvLyBJbmplY3QgdGFibGUgYm9keSBzdGFydC5cbiAgICAgICAgaWYgKGFmdGVySGVhZEF3YWl0aW5nRmlyc3RCb2R5Um93KSB7XG4gICAgICAgICAgYWZ0ZXJIZWFkQXdhaXRpbmdGaXJzdEJvZHlSb3cgPSBmYWxzZVxuICAgICAgICAgIGN1cnJlbnRCb2R5ID0ge1xuICAgICAgICAgICAgdHlwZTogJ3RhYmxlQm9keScsXG4gICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgdG9rZW4uc3RhcnQpLFxuICAgICAgICAgICAgLy8gTm90ZTogY29ycmVjdCBlbmQgaXMgc2V0IGxhdGVyLlxuICAgICAgICAgICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCB0b2tlbi5lbmQpXG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcC5hZGQoaW5kZXgsIDAsIFtbJ2VudGVyJywgY3VycmVudEJvZHksIGNvbnRleHRdXSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJvd0tpbmQgPSB0b2tlbi50eXBlID09PSAndGFibGVEZWxpbWl0ZXJSb3cnID8gMiA6IGN1cnJlbnRCb2R5ID8gMyA6IDFcbiAgICAgIH1cbiAgICAgIC8vIENlbGwgZGF0YS5cbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICByb3dLaW5kICYmXG4gICAgICAgICh0b2tlbi50eXBlID09PSB0eXBlcy5kYXRhIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyTWFya2VyJyB8fFxuICAgICAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZURlbGltaXRlckZpbGxlcicpXG4gICAgICApIHtcbiAgICAgICAgaW5GaXJzdENlbGxBd2FpdGluZ1BpcGUgPSBmYWxzZVxuXG4gICAgICAgIC8vIEZpcnN0IHZhbHVlIGluIGNlbGwuXG4gICAgICAgIGlmIChjZWxsWzJdID09PSAwKSB7XG4gICAgICAgICAgaWYgKGxhc3RDZWxsWzFdICE9PSAwKSB7XG4gICAgICAgICAgICBjZWxsWzBdID0gY2VsbFsxXVxuICAgICAgICAgICAgY3VycmVudENlbGwgPSBmbHVzaENlbGwoXG4gICAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgbGFzdENlbGwsXG4gICAgICAgICAgICAgIHJvd0tpbmQsXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgY3VycmVudENlbGxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGxhc3RDZWxsID0gWzAsIDAsIDAsIDBdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2VsbFsyXSA9IGluZGV4XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gJ3RhYmxlQ2VsbERpdmlkZXInKSB7XG4gICAgICAgIGlmIChpbkZpcnN0Q2VsbEF3YWl0aW5nUGlwZSkge1xuICAgICAgICAgIGluRmlyc3RDZWxsQXdhaXRpbmdQaXBlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGFzdENlbGxbMV0gIT09IDApIHtcbiAgICAgICAgICAgIGNlbGxbMF0gPSBjZWxsWzFdXG4gICAgICAgICAgICBjdXJyZW50Q2VsbCA9IGZsdXNoQ2VsbChcbiAgICAgICAgICAgICAgbWFwLFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICBsYXN0Q2VsbCxcbiAgICAgICAgICAgICAgcm93S2luZCxcbiAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjdXJyZW50Q2VsbFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxhc3RDZWxsID0gY2VsbFxuICAgICAgICAgIGNlbGwgPSBbbGFzdENlbGxbMV0sIGluZGV4LCAwLCAwXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV4aXQgZXZlbnRzLlxuICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICd0YWJsZUhlYWQnKSB7XG4gICAgICBhZnRlckhlYWRBd2FpdGluZ0ZpcnN0Qm9keVJvdyA9IHRydWVcbiAgICAgIGxhc3RUYWJsZUVuZCA9IGluZGV4XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZVJvdycgfHxcbiAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZURlbGltaXRlclJvdydcbiAgICApIHtcbiAgICAgIGxhc3RUYWJsZUVuZCA9IGluZGV4XG5cbiAgICAgIGlmIChsYXN0Q2VsbFsxXSAhPT0gMCkge1xuICAgICAgICBjZWxsWzBdID0gY2VsbFsxXVxuICAgICAgICBjdXJyZW50Q2VsbCA9IGZsdXNoQ2VsbChcbiAgICAgICAgICBtYXAsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBsYXN0Q2VsbCxcbiAgICAgICAgICByb3dLaW5kLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGN1cnJlbnRDZWxsXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAoY2VsbFsxXSAhPT0gMCkge1xuICAgICAgICBjdXJyZW50Q2VsbCA9IGZsdXNoQ2VsbChtYXAsIGNvbnRleHQsIGNlbGwsIHJvd0tpbmQsIGluZGV4LCBjdXJyZW50Q2VsbClcbiAgICAgIH1cblxuICAgICAgcm93S2luZCA9IDBcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcm93S2luZCAmJlxuICAgICAgKHRva2VuLnR5cGUgPT09IHR5cGVzLmRhdGEgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyTWFya2VyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAndGFibGVEZWxpbWl0ZXJGaWxsZXInKVxuICAgICkge1xuICAgICAgY2VsbFszXSA9IGluZGV4XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhc3RUYWJsZUVuZCAhPT0gMCkge1xuICAgIGFzc2VydChjdXJyZW50VGFibGUsICdleHBlY3RlZCB0YWJsZSBvcGVuaW5nJylcbiAgICBmbHVzaFRhYmxlRW5kKG1hcCwgY29udGV4dCwgbGFzdFRhYmxlRW5kLCBjdXJyZW50VGFibGUsIGN1cnJlbnRCb2R5KVxuICB9XG5cbiAgbWFwLmNvbnN1bWUoY29udGV4dC5ldmVudHMpXG5cbiAgLy8gVG8gZG86IG1vdmUgdGhpcyBpbnRvIGBodG1sYCwgd2hlbiBldmVudHMgYXJlIGV4cG9zZWQgdGhlcmUuXG4gIC8vIFRoYXTigJlzIHdoYXQgYG1hcmtkb3duLXJzYCBkb2VzLlxuICAvLyBUaGF0IG5lZWRzIHVwZGF0ZXMgdG8gYG1kYXN0LXV0aWwtZ2ZtLXRhYmxlYC5cbiAgaW5kZXggPSAtMVxuICB3aGlsZSAoKytpbmRleCA8IGNvbnRleHQuZXZlbnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGV2ZW50ID0gY29udGV4dC5ldmVudHNbaW5kZXhdXG4gICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInICYmIGV2ZW50WzFdLnR5cGUgPT09ICd0YWJsZScpIHtcbiAgICAgIGV2ZW50WzFdLl9hbGlnbiA9IGdmbVRhYmxlQWxpZ24oY29udGV4dC5ldmVudHMsIGluZGV4KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudHNcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGNlbGwuXG4gKlxuICogQHBhcmFtIHtFZGl0TWFwfSBtYXBcbiAqIEBwYXJhbSB7UmVhZG9ubHk8VG9rZW5pemVDb250ZXh0Pn0gY29udGV4dFxuICogQHBhcmFtIHtSZWFkb25seTxSYW5nZT59IHJhbmdlXG4gKiBAcGFyYW0ge1Jvd0tpbmR9IHJvd0tpbmRcbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSByb3dFbmRcbiAqIEBwYXJhbSB7VG9rZW4gfCB1bmRlZmluZWR9IHByZXZpb3VzQ2VsbFxuICogQHJldHVybnMge1Rva2VuIHwgdW5kZWZpbmVkfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZnVuY3Rpb24gZmx1c2hDZWxsKG1hcCwgY29udGV4dCwgcmFuZ2UsIHJvd0tpbmQsIHJvd0VuZCwgcHJldmlvdXNDZWxsKSB7XG4gIC8vIGBtYXJrZG93bi1yc2AgdXNlczpcbiAgLy8gcm93S2luZCA9PT0gMiA/ICd0YWJsZURlbGltaXRlckNlbGwnIDogJ3RhYmxlQ2VsbCdcbiAgY29uc3QgZ3JvdXBOYW1lID1cbiAgICByb3dLaW5kID09PSAxXG4gICAgICA/ICd0YWJsZUhlYWRlcidcbiAgICAgIDogcm93S2luZCA9PT0gMlxuICAgICAgICA/ICd0YWJsZURlbGltaXRlcidcbiAgICAgICAgOiAndGFibGVEYXRhJ1xuICAvLyBgbWFya2Rvd24tcnNgIHVzZXM6XG4gIC8vIHJvd0tpbmQgPT09IDIgPyAndGFibGVEZWxpbWl0ZXJDZWxsVmFsdWUnIDogJ3RhYmxlQ2VsbFRleHQnXG4gIGNvbnN0IHZhbHVlTmFtZSA9ICd0YWJsZUNvbnRlbnQnXG5cbiAgLy8gSW5zZXJ0IGFuIGV4aXQgZm9yIHRoZSBwcmV2aW91cyBjZWxsLCBpZiB0aGVyZSBpcyBvbmUuXG4gIC8vXG4gIC8vIGBgYG1hcmtkb3duXG4gIC8vID4gfCB8IGFhIHwgYmIgfCBjYyB8XG4gIC8vICAgICAgICAgIF4tLSBleGl0XG4gIC8vICAgICAgICAgICBeXl5eLS0gdGhpcyBjZWxsXG4gIC8vIGBgYFxuICBpZiAocmFuZ2VbMF0gIT09IDApIHtcbiAgICBhc3NlcnQocHJldmlvdXNDZWxsLCAnZXhwZWN0ZWQgcHJldmlvdXMgY2VsbCBlbnRlcicpXG4gICAgcHJldmlvdXNDZWxsLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIGdldFBvaW50KGNvbnRleHQuZXZlbnRzLCByYW5nZVswXSkpXG4gICAgbWFwLmFkZChyYW5nZVswXSwgMCwgW1snZXhpdCcsIHByZXZpb3VzQ2VsbCwgY29udGV4dF1dKVxuICB9XG5cbiAgLy8gSW5zZXJ0IGVudGVyIG9mIHRoaXMgY2VsbC5cbiAgLy9cbiAgLy8gYGBgbWFya2Rvd25cbiAgLy8gPiB8IHwgYWEgfCBiYiB8IGNjIHxcbiAgLy8gICAgICAgICAgIF4tLSBlbnRlclxuICAvLyAgICAgICAgICAgXl5eXi0tIHRoaXMgY2VsbFxuICAvLyBgYGBcbiAgY29uc3Qgbm93ID0gZ2V0UG9pbnQoY29udGV4dC5ldmVudHMsIHJhbmdlWzFdKVxuICBwcmV2aW91c0NlbGwgPSB7XG4gICAgdHlwZTogZ3JvdXBOYW1lLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBub3cpLFxuICAgIC8vIE5vdGU6IGNvcnJlY3QgZW5kIGlzIHNldCBsYXRlci5cbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIG5vdylcbiAgfVxuICBtYXAuYWRkKHJhbmdlWzFdLCAwLCBbWydlbnRlcicsIHByZXZpb3VzQ2VsbCwgY29udGV4dF1dKVxuXG4gIC8vIEluc2VydCB0ZXh0IHN0YXJ0IGF0IGZpcnN0IGRhdGEgc3RhcnQgYW5kIGVuZCBhdCBsYXN0IGRhdGEgZW5kLCBhbmRcbiAgLy8gcmVtb3ZlIGV2ZW50cyBiZXR3ZWVuLlxuICAvL1xuICAvLyBgYGBtYXJrZG93blxuICAvLyA+IHwgfCBhYSB8IGJiIHwgY2MgfFxuICAvLyAgICAgICAgICAgIF4tLSBlbnRlclxuICAvLyAgICAgICAgICAgICBeLS0gZXhpdFxuICAvLyAgICAgICAgICAgXl5eXi0tIHRoaXMgY2VsbFxuICAvLyBgYGBcbiAgaWYgKHJhbmdlWzJdICE9PSAwKSB7XG4gICAgY29uc3QgcmVsYXRlZFN0YXJ0ID0gZ2V0UG9pbnQoY29udGV4dC5ldmVudHMsIHJhbmdlWzJdKVxuICAgIGNvbnN0IHJlbGF0ZWRFbmQgPSBnZXRQb2ludChjb250ZXh0LmV2ZW50cywgcmFuZ2VbM10pXG4gICAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgICBjb25zdCB2YWx1ZVRva2VuID0ge1xuICAgICAgdHlwZTogdmFsdWVOYW1lLFxuICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIHJlbGF0ZWRTdGFydCksXG4gICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIHJlbGF0ZWRFbmQpXG4gICAgfVxuICAgIG1hcC5hZGQocmFuZ2VbMl0sIDAsIFtbJ2VudGVyJywgdmFsdWVUb2tlbiwgY29udGV4dF1dKVxuICAgIGFzc2VydChyYW5nZVszXSAhPT0gMClcblxuICAgIGlmIChyb3dLaW5kICE9PSAyKSB7XG4gICAgICAvLyBGaXggcG9zaXRpb25hbCBpbmZvIG9uIHJlbWFpbmluZyBldmVudHNcbiAgICAgIGNvbnN0IHN0YXJ0ID0gY29udGV4dC5ldmVudHNbcmFuZ2VbMl1dXG4gICAgICBjb25zdCBlbmQgPSBjb250ZXh0LmV2ZW50c1tyYW5nZVszXV1cbiAgICAgIHN0YXJ0WzFdLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIGVuZFsxXS5lbmQpXG4gICAgICBzdGFydFsxXS50eXBlID0gdHlwZXMuY2h1bmtUZXh0XG4gICAgICBzdGFydFsxXS5jb250ZW50VHlwZSA9IGNvbnN0YW50cy5jb250ZW50VHlwZVRleHRcblxuICAgICAgLy8gUmVtb3ZlIGlmIG5lZWRlZC5cbiAgICAgIGlmIChyYW5nZVszXSA+IHJhbmdlWzJdICsgMSkge1xuICAgICAgICBjb25zdCBhID0gcmFuZ2VbMl0gKyAxXG4gICAgICAgIGNvbnN0IGIgPSByYW5nZVszXSAtIHJhbmdlWzJdIC0gMVxuICAgICAgICBtYXAuYWRkKGEsIGIsIFtdKVxuICAgICAgfVxuICAgIH1cblxuICAgIG1hcC5hZGQocmFuZ2VbM10gKyAxLCAwLCBbWydleGl0JywgdmFsdWVUb2tlbiwgY29udGV4dF1dKVxuICB9XG5cbiAgLy8gSW5zZXJ0IGFuIGV4aXQgZm9yIHRoZSBsYXN0IGNlbGwsIGlmIGF0IHRoZSByb3cgZW5kLlxuICAvL1xuICAvLyBgYGBtYXJrZG93blxuICAvLyA+IHwgfCBhYSB8IGJiIHwgY2MgfFxuICAvLyAgICAgICAgICAgICAgICAgICAgXi0tIGV4aXRcbiAgLy8gICAgICAgICAgICAgICBeXl5eXl4tLSB0aGlzIGNlbGwgKHRoZSBsYXN0IG9uZSBjb250YWlucyB0d28g4oCcYmV0d2VlbuKAnSBwYXJ0cylcbiAgLy8gYGBgXG4gIGlmIChyb3dFbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHByZXZpb3VzQ2VsbC5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBnZXRQb2ludChjb250ZXh0LmV2ZW50cywgcm93RW5kKSlcbiAgICBtYXAuYWRkKHJvd0VuZCwgMCwgW1snZXhpdCcsIHByZXZpb3VzQ2VsbCwgY29udGV4dF1dKVxuICAgIHByZXZpb3VzQ2VsbCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIHByZXZpb3VzQ2VsbFxufVxuXG4vKipcbiAqIEdlbmVyYXRlIHRhYmxlIGVuZCAoYW5kIHRhYmxlIGJvZHkgZW5kKS5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5PEVkaXRNYXA+fSBtYXBcbiAqIEBwYXJhbSB7UmVhZG9ubHk8VG9rZW5pemVDb250ZXh0Pn0gY29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge1Rva2VufSB0YWJsZVxuICogQHBhcmFtIHtUb2tlbiB8IHVuZGVmaW5lZH0gdGFibGVCb2R5XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5mdW5jdGlvbiBmbHVzaFRhYmxlRW5kKG1hcCwgY29udGV4dCwgaW5kZXgsIHRhYmxlLCB0YWJsZUJvZHkpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxFdmVudD59ICovXG4gIGNvbnN0IGV4aXRzID0gW11cbiAgY29uc3QgcmVsYXRlZCA9IGdldFBvaW50KGNvbnRleHQuZXZlbnRzLCBpbmRleClcblxuICBpZiAodGFibGVCb2R5KSB7XG4gICAgdGFibGVCb2R5LmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIHJlbGF0ZWQpXG4gICAgZXhpdHMucHVzaChbJ2V4aXQnLCB0YWJsZUJvZHksIGNvbnRleHRdKVxuICB9XG5cbiAgdGFibGUuZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgcmVsYXRlZClcbiAgZXhpdHMucHVzaChbJ2V4aXQnLCB0YWJsZSwgY29udGV4dF0pXG5cbiAgbWFwLmFkZChpbmRleCArIDEsIDAsIGV4aXRzKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhZG9ubHk8QXJyYXk8RXZlbnQ+Pn0gZXZlbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm5zIHtSZWFkb25seTxQb2ludD59XG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50KGV2ZW50cywgaW5kZXgpIHtcbiAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXhdXG4gIGNvbnN0IHNpZGUgPSBldmVudFswXSA9PT0gJ2VudGVyJyA/ICdzdGFydCcgOiAnZW5kJ1xuICByZXR1cm4gZXZlbnRbMV1bc2lkZV1cbn1cbiJdLCJuYW1lcyI6WyJvayIsImFzc2VydCIsImZhY3RvcnlTcGFjZSIsIm1hcmtkb3duTGluZUVuZGluZyIsIm1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UiLCJtYXJrZG93blNwYWNlIiwiY29kZXMiLCJjb25zdGFudHMiLCJ0eXBlcyIsIkVkaXRNYXAiLCJnZm1UYWJsZUFsaWduIiwiZ2ZtVGFibGUiLCJmbG93IiwibnVsbCIsIm5hbWUiLCJ0b2tlbml6ZSIsInRva2VuaXplVGFibGUiLCJyZXNvbHZlQWxsIiwicmVzb2x2ZVRhYmxlIiwiZWZmZWN0cyIsIm5vayIsInNlbGYiLCJzaXplIiwic2l6ZUIiLCJzZWVuIiwic3RhcnQiLCJjb2RlIiwiaW5kZXgiLCJldmVudHMiLCJsZW5ndGgiLCJ0eXBlIiwibGluZUVuZGluZyIsImxpbmVQcmVmaXgiLCJ0YWlsIiwibmV4dCIsImJvZHlSb3dTdGFydCIsImhlYWRSb3dCZWZvcmUiLCJwYXJzZXIiLCJsYXp5Iiwibm93IiwibGluZSIsImVudGVyIiwiaGVhZFJvd1N0YXJ0IiwidmVydGljYWxCYXIiLCJoZWFkUm93QnJlYWsiLCJlb2YiLCJpbnRlcnJ1cHQiLCJleGl0IiwiY29uc3VtZSIsImhlYWREZWxpbWl0ZXJTdGFydCIsIndoaXRlc3BhY2UiLCJkYXRhIiwiaGVhZFJvd0RhdGEiLCJiYWNrc2xhc2giLCJoZWFkUm93RXNjYXBlIiwiY29uc3RydWN0cyIsImRpc2FibGUiLCJoZWFkRGVsaW1pdGVyQmVmb3JlIiwiaW5jbHVkZXMiLCJ1bmRlZmluZWQiLCJ0YWJTaXplIiwiZGFzaCIsImNvbG9uIiwiaGVhZERlbGltaXRlclZhbHVlQmVmb3JlIiwiaGVhZERlbGltaXRlckNlbGxCZWZvcmUiLCJoZWFkRGVsaW1pdGVyTm9rIiwiaGVhZERlbGltaXRlckxlZnRBbGlnbm1lbnRBZnRlciIsImhlYWREZWxpbWl0ZXJDZWxsQWZ0ZXIiLCJoZWFkRGVsaW1pdGVyRmlsbGVyIiwiaGVhZERlbGltaXRlclJpZ2h0QWxpZ25tZW50QWZ0ZXIiLCJib2R5Um93QnJlYWsiLCJib2R5Um93RGF0YSIsImJvZHlSb3dFc2NhcGUiLCJjb250ZXh0IiwiaW5GaXJzdENlbGxBd2FpdGluZ1BpcGUiLCJyb3dLaW5kIiwibGFzdENlbGwiLCJjZWxsIiwiYWZ0ZXJIZWFkQXdhaXRpbmdGaXJzdEJvZHlSb3ciLCJsYXN0VGFibGVFbmQiLCJjdXJyZW50VGFibGUiLCJjdXJyZW50Qm9keSIsImN1cnJlbnRDZWxsIiwibWFwIiwiZXZlbnQiLCJ0b2tlbiIsImZsdXNoVGFibGVFbmQiLCJPYmplY3QiLCJhc3NpZ24iLCJlbmQiLCJhZGQiLCJmbHVzaENlbGwiLCJfYWxpZ24iLCJyYW5nZSIsInJvd0VuZCIsInByZXZpb3VzQ2VsbCIsImdyb3VwTmFtZSIsInZhbHVlTmFtZSIsImdldFBvaW50IiwicmVsYXRlZFN0YXJ0IiwicmVsYXRlZEVuZCIsInZhbHVlVG9rZW4iLCJjaHVua1RleHQiLCJjb250ZW50VHlwZSIsImNvbnRlbnRUeXBlVGV4dCIsImEiLCJiIiwidGFibGUiLCJ0YWJsZUJvZHkiLCJleGl0cyIsInJlbGF0ZWQiLCJwdXNoIiwic2lkZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js\n");

/***/ })

};
;